<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>3D Maze Diamond Hunt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    /* ===== HUD ===== */
    #overlay{
      position:fixed;top:10px;left:10px;z-index:10;
      font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;color:#fff;pointer-events:none;
    }
    #hud{display:flex;align-items:center;gap:10px;background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.2);border-radius:12px;padding:8px 10px}
    .pill{
      display:flex;align-items:center;gap:6px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.18);border-radius:999px;padding:6px 10px
    }
    .pill span{font-weight:700;min-width:24px;text-align:right}
    .ico{width:18px;height:18px;display:block}
    .blue{fill:#00d0ff}
    .gray{fill:#a9b3c4}
    .green{fill:#6cff8f}
    #perks{display:flex;gap:8px;margin-left:6px}
    .perk{
      position:relative;width:28px;height:28px;border-radius:8px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);
      display:flex;align-items:center;justify-content:center;opacity:.55
    }
    .perk.on{opacity:1;border-color:rgba(90,255,120,.6);box-shadow:0 0 0 2px rgba(90,255,120,.2) inset}
    .perk.can{opacity:.9;border-color:rgba(120,180,255,.7);box-shadow:0 0 0 2px rgba(120,180,255,.2) inset}
    .perk .price{
      position:absolute;bottom:-8px;right:-6px;font:10px/1.1 system-ui,Segoe UI,Roboto,Arial,sans-serif;
      background:rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.25);color:#fff;padding:1px 4px;border-radius:6px
    }
    .perk.on .price{display:none}
    #modeText{display:none} /* –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –∫–æ–¥–∞ */
    /* ===== Map/View & rings ===== */
    #map3d{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      width:min(90vw,900px);height:min(70vh,650px);display:none;z-index:20;border-radius:12px;background:transparent
    }
    #exitRing, #buyRing{
      position:fixed;left:50%;bottom:26px;transform:translateX(-50%);
      width:84px;height:84px;border-radius:50%;
      background:conic-gradient(#44ff77 0deg, rgba(255,255,255,0.12) 0deg 360deg);
      border:3px solid rgba(255,255,255,0.35);
      box-shadow:0 8px 28px rgba(0,0,0,.5);
      display:none;z-index:25
    }
    #buyRing:after{
      content:"–ü–æ–∫—É–ø–∫–∞ –ø—Ä—ã–∂–∫–∞"; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      color:#fff; font:12px/1.1 system-ui,Segoe UI,Roboto,Arial,sans-serif; text-align:center; width:90px
    }
    #exitWarn{
      position:fixed;left:50%;bottom:120px;transform:translateX(-50%);
      color:#fff;background:rgba(0,0,0,.6);padding:8px 12px;border-radius:8px;font:14px system-ui,Segoe UI,Roboto,Arial,sans-serif;
      display:none;z-index:25
    }
    /* ===== Main menu ===== */
    #mainMenu{
      position:fixed;inset:0;background:linear-gradient(135deg,#0b0f1a, #182033);
      color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;z-index:100;display:flex;align-items:center;justify-content:center;
    }
    #menuCard{
      width:min(92vw,720px);background:rgba(255,255,255,0.06);backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,0.15);border-radius:14px;padding:20px 24px;box-shadow:0 20px 60px rgba(0,0,0,.5)
    }
    #menuCard h1{margin:0 0 10px 0;font-size:28px}
    #menuCard p{margin:6px 0 14px 0;color:#cfd8ff}
    .menuRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .btn{
      padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.08);color:#fff;cursor:pointer;font-weight:600
    }
    .btn:hover{background:rgba(255,255,255,0.14)}
    .input{
      flex:1;min-width:260px;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.35);color:#fff;outline:none
    }
    /* ===== Toasts ===== */
    #toastWrap{
      position:fixed;left:50%;top:18px;transform:translateX(-50%);
      display:flex;flex-direction:column;gap:8px;z-index:200;pointer-events:none
    }
    .toast{
      background:rgba(0,0,0,.7);color:#fff;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.2);
      font:14px system-ui,Segoe UI,Roboto,Arial,sans-serif; opacity:0; transform:translateY(-8px);
      transition:opacity .2s ease, transform .2s ease; pointer-events:none; max-width:86vw
    }
    .toast.show{opacity:1; transform:translateY(0)}
    .toast.success{border-color:rgba(90,255,120,.5)}
    .toast.warn{border-color:rgba(255,230,90,.6)}
    .toast.err{border-color:rgba(255,120,120,.6)}
    /* ===== Mobile UI ===== */
    #mobileUI{display:none;position:fixed;inset:0;pointer-events:none;z-index:30}
    #lookPad{position:fixed;inset:0;pointer-events:auto;touch-action:none}
    .stickWrap{
      position:absolute;left:14px;bottom:14px;width:140px;height:140px;border-radius:50%;
      background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.15);pointer-events:auto;touch-action:none
    }
    .stickKnob{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,0.25);border:1px solid rgba(255,255,255,0.35)
    }
    .mobBtns{position:absolute;right:14px;bottom:14px;display:flex;flex-direction:column;gap:10px;pointer-events:auto}
    .mobBtn{
      min-width:100px;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.35);color:#fff;text-align:center;font-weight:700
    }
    .mobRow{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    /* Responsive menu text with controls */
    @media (max-width:720px){
      #menuCard{width:92vw}
      .menuRow{flex-direction:column}
      .input{min-width:unset;width:100%}
      .btn{width:100%}
    }
  </style>
</head>
<body>
  <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
  <div id="mainMenu">
    <div id="menuCard">
      <h1>Maze Diamond Hunt</h1>
      <p>–í—Å—Ç–∞–≤—å—Ç–µ –∫–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ, –∏–ª–∏ –Ω–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –∑–∞–±–µ–≥: –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π / —Å –±–∏–æ–º–∞–º–∏ –∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏.</p>
      <div class="menuRow">
        <input id="menuSaveInput" class="input" placeholder="–ö–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è" />
        <button id="btnContinue" class="btn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ –∫–æ–¥—É</button>
      </div>
      <div class="menuRow">
        <button id="btnClassic" class="btn">–ù–æ–≤—ã–π –∑–∞–±–µ–≥ ‚Äî –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π</button>
        <button id="btnBiomes" class="btn">–ù–æ–≤—ã–π –∑–∞–±–µ–≥ ‚Äî –ë–∏–æ–º—ã</button>
      </div>
      <div class="menuRow" style="align-items:center">
        <label for="sizeMulInput" style="min-width:160px">–ú–∞—Å—à—Ç–∞–± –∫–∞—Ä—Ç—ã: √ó<span id="sizeMulLabel">1</span></label>
        <input id="sizeMulInput" type="range" min="1" max="50" step="1" value="1" style="flex:1" list="sizeTicks" />
        <datalist id="sizeTicks">
          <option value="1"></option>
          <option value="5"></option>
          <option value="10"></option>
          <option value="20"></option>
          <option value="30"></option>
          <option value="40"></option>
          <option value="50"></option>
        </datalist>
      </div>
      <p style="margin-top:16px;font-size:12px;opacity:.85">
        –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–ü–ö): –∫–ª–∏–∫ –ø–æ –∏–≥—Ä–µ ‚Äî –∑–∞—Ö–≤–∞—Ç –º—ã—à–∏; WASD ‚Äî —Ö–æ–¥—å–±–∞; Space ‚Äî –ø—Ä—ã–∂–æ–∫; –¥–≤–æ–π–Ω–æ–π Space ‚Äî –ø–æ–ª—ë—Ç; Shift ‚Äî —Å–Ω–∏–∂–µ–Ω–∏–µ;
        M ‚Äî 3D-–∫–∞—Ä—Ç–∞; 0 ‚Äî –æ—Ç–ª–∞–¥–∫–∞ (FPS/–º–µ—Ç—Ä–∏–∫–∏); Q ‚Äî –∫–∞—á–µ—Å—Ç–≤–æ (LOW/MED/HIGH); 7 ‚Äî –∑–∞—Å–ø–∞–≤–Ω–∏—Ç—å –º—ã—à—å;
        1 ‚Äî —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å; 2 ‚Äî –∑–∞–≥—Ä—É–∑–∏—Ç—å; 3 ‚Äî +100; 4 ‚Äî –º–µ–Ω—é.
        –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö: –ª–µ–≤—ã–π —Å—Ç–∏–∫ (—Ö–æ–¥—å–±–∞), —Å–≤–∞–π–ø —Å–ø—Ä–∞–≤–∞ (–≤–∑–≥–ª—è–¥), ¬´–ü—Ä—ã–∂–æ–∫/–°–Ω–∏–∂–µ–Ω–∏–µ¬ª, ¬´–ö–∞—Ä—Ç–∞¬ª, ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª, ¬´–ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω¬ª, ¬´–ú–µ–Ω—é¬ª.
      </p>
    </div>
  </div>

  <!-- HUD: —Ç–æ–ª—å–∫–æ –∏–∫–æ–Ω–∫–∏-—Å—á—ë—Ç—á–∏–∫–∏ –∏ —Å—Ç–∞—Ç—É—Å—ã -->
  <div id="overlay">
    <div id="hud">
      <!-- carried -->
      <div class="pill" title="–ê–ª–º–∞–∑—ã –ø—Ä–∏ —Å–µ–±–µ">
        <span class="ico">üíé</span>
        <span style="margin-right:6px">–∞–ª–º–∞–∑–æ–≤</span>
        <span id="diamondCount">0</span>
      </div>
      <!-- total -->
      <div class="pill" title="–ê–ª–º–∞–∑—ã –≤—Å–µ–≥–æ">
        <span class="ico">üßä</span>
        <span style="margin-right:6px">–∞–ª–º–∞–∑–æ–≤ –≤—Å–µ–≥–æ</span>
        <span id="totalDiamonds">0</span>
      </div>
      <!-- levels -->
      <div class="pill" title="–ü—Ä–æ–π–¥–µ–Ω–æ —É—Ä–æ–≤–Ω–µ–π">
        <span class="ico">üö©</span>
        <span style="margin-right:6px">–ø—Ä–æ–π–¥–µ–Ω–æ —É—Ä–æ–≤–Ω–µ–π</span>
        <span id="levelsCleared">0</span>
      </div>
      <!-- mice caught -->
      <div class="pill" title="–ü–æ–π–º–∞–Ω–æ –º—ã—à–µ–π">
        <span class="ico" style="font-size:18px;line-height:18px">üê≠</span>
        <span style="margin-right:6px">–º—ã—à–∏</span>
        <span id="miceCaught">0</span>
      </div>

      <div id="perks">
        <span style="margin:0 4px 0 2px">üó∫–∫–∞—Ä—Ç–∞</span>
        <!-- Map perk -->
        <div id="perkMap" class="perk" title="–ö–∞—Ä—Ç–∞ —É—Ä–æ–≤–Ω—è (20)">
          <svg class="ico" viewBox="0 0 18 18" style="fill:#cfe3ff">
            <path d="M3 4l4-2 4 2 4-2v12l-4 2-4-2-4 2V4zM7 4v10M11 6v10" />
          </svg>
          <span class="price">20</span>
        </div>
        <span style="margin:0 4px 0 8px">üîº –ø—Ä—ã–∂–∫–∏</span>
        <!-- Jump perk (Classic) -->
        <div id="perkJump" class="perk" title="–ü—Ä—ã–∂–æ–∫ (10, —Ç–æ–ª—å–∫–æ Classic)">
          <svg class="ico" viewBox="0 0 18 18" style="fill:#cfe3ff">
            <path d="M9 3l4 4H10v8H8V7H5l4-4z"/>
          </svg>
          <span class="price">10</span>
        </div>
      </div>
      <span id="modeText"></span>
    </div>
  </div>

  <canvas id="map3d"></canvas>
  <div id="exitRing"></div>
  <div id="buyRing"></div>
  <div id="exitWarn">–ù—É–∂–Ω–æ –ø—Ä–∏–Ω–µ—Å—Ç–∏ 10 –∞–ª–º–∞–∑–æ–≤, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</div>
  <div id="toastWrap"></div>

  <!-- –ú–æ–±–∏–ª—å–Ω—ã–π UI -->
  <div id="mobileUI">
    <div id="lookPad"></div>
    <div class="stickWrap" id="stickL"><div class="stickKnob" id="stickKnob"></div></div>
    <div class="mobBtns">
      <div class="mobRow">
        <button class="mobBtn" id="btnJump">–ü—Ä—ã–∂–æ–∫</button>
        <button class="mobBtn" id="btnDown">–°–Ω–∏–∂–µ–Ω–∏–µ</button>
      </div>
      <div class="mobRow">
        <button class="mobBtn" id="btnMap">–ö–∞—Ä—Ç–∞</button>
        <button class="mobBtn" id="btnSave">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        <button class="mobBtn" id="btnFS">–ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω</button>
        <button class="mobBtn" id="btnMenu">–ú–µ–Ω—é</button>
      </div>
    </div>
  </div>

<script type="module">
/* ===== Save system with optional mouse suffix ===== */

const diamondUI = document.getElementById('diamondCount');
const totalUI   = document.getElementById('totalDiamonds');
const levelsUI  = document.getElementById('levelsCleared');
const modeUI    = document.getElementById('modeText');
const mapCanvas = document.getElementById('map3d');
const exitRing  = document.getElementById('exitRing');
const buyRing   = document.getElementById('buyRing');
const exitWarn  = document.getElementById('exitWarn');
const toastWrap = document.getElementById('toastWrap');

  const mainMenu   = document.getElementById('mainMenu');
  const menuInput  = document.getElementById('menuSaveInput');
  const btnContinue= document.getElementById('btnContinue');
  const btnClassic = document.getElementById('btnClassic');
  const btnBiomes  = document.getElementById('btnBiomes');
  let sizeMulInput = null; let sizeMulLabel = null;

/* perks icons */
const perkMap  = document.getElementById('perkMap');
const perkJump = document.getElementById('perkJump');

/* mobile refs */
const mobileUI = document.getElementById('mobileUI');
const lookPad  = document.getElementById('lookPad');
const stickL   = document.getElementById('stickL');
const stickKnob= document.getElementById('stickKnob');
const btnJump  = document.getElementById('btnJump');
const btnDown  = document.getElementById('btnDown');
const btnMapBtn= document.getElementById('btnMap');
const btnSave  = document.getElementById('btnSave');
const btnFS    = document.getElementById('btnFS');
const btnMenu  = document.getElementById('btnMenu');

// Debug panel element (hidden by default)
const debugPanel = document.createElement('div');
debugPanel.id = 'debugPanel';
debugPanel.style.cssText = 'margin-top:8px; font:12px/1.2 monospace; background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,.2); border-radius:8px; padding:6px 8px; display:none; max-width:72vw; white-space:pre-wrap;';
document.getElementById('overlay').appendChild(debugPanel);

function showToast(msg, type='success', ms=2200){
  const el = document.createElement('div');
  el.className = `toast ${type}`;
  el.textContent = msg;
  toastWrap.appendChild(el);
  requestAnimationFrame(()=>el.classList.add('show'));
  setTimeout(()=>{ el.classList.remove('show'); setTimeout(()=>toastWrap.removeChild(el), 220); }, ms);
}
async function copyText(text){
  try{ await navigator.clipboard.writeText(text); return true; }
  catch{
    const ta = document.createElement('textarea');
    ta.value = text; document.body.appendChild(ta);
    ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
    return true;
  }
}

async function loadLibs(){
  return {
    THREE: await import('./vendor/three/three.module.js'),
    PLC: (await import('./vendor/three/PointerLockControls.js')).PointerLockControls,
    OBJLoader: (await import('./vendor/three/OBJLoader.js')).OBJLoader
  };
}

(async ()=>{
  let THREE, PointerLockControls, OBJLoader;
  try{
    const libs = await loadLibs();
    THREE = libs.THREE; PointerLockControls = libs.PLC; OBJLoader = libs.OBJLoader;
  }catch(e){
    console.error(e);
    showToast('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å three.js', 'err', 3000);
    return;
  }

  const isMobile = /Android|iPhone|iPad|iPod|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent)
                    || (('ontouchstart' in window) && window.matchMedia('(max-width: 900px)').matches);

  const cellSize = 5;
  const BASE_MAZE_SIZE = 15;
  const BASE_TO_WIN = 10;
  const BASE_DIAMOND_COUNT = 15;
  let sizeMul = 1;
  let mazeSize = BASE_MAZE_SIZE;
  let toWin = BASE_TO_WIN;
  const playerRadius = cellSize*0.35, WALL_HEIGHT = cellSize;
  let DIAMOND_COUNT = BASE_DIAMOND_COUNT;
  const SUPER_CHANCE = 0.12;

  function LCG(seedInit=1){
    let s = (seedInit>>>0)||1; const a = 1664525>>>0, c = 1013904223>>>0;
    return { set(v){ s=(v>>>0)||1; }, next(){ s=(Math.imul(a,s)+c)>>>0; return s; },
      float(){ return this.next()/4294967296; }, int(n){ return Math.floor(this.next()/4294967296*n); }, raw(){return s>>>0;} };
  }
  let mazeSeed = 0x1234, diamondsSeed = 0xBEEF, biomeSeed = 0xA55A;
  const rngMaze = LCG(mazeSeed), rngDiam = LCG(diamondsSeed), rngBiome = LCG(biomeSeed);
  const randIntM = n => rngMaze.int(n);
  function reseedMaze(s){ mazeSeed = (s & 0x07FF)>>>0; rngMaze.set(mazeSeed); }
  function reseedDiam(s){ diamondsSeed = (s & 0x07FF)>>>0; rngDiam.set(diamondsSeed); }
  function reseedBiome(s){ biomeSeed = (s & 0x07FF)>>>0; rngBiome.set(biomeSeed); }

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.add(new THREE.Mesh(new THREE.SphereGeometry(1500, 32, 32),
    new THREE.MeshBasicMaterial({ color:0x87CEEB, side:THREE.BackSide })));

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.rotation.order = 'YXZ';
  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
  // Quality preset and pixel ratio cap; adjusted later
  let quality = 'high';
  let pixelRatioCap = 2;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, pixelRatioCap));
  if (THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  let mapRenderer; // will be created later for 3D map
  const controls = new PointerLockControls(camera, renderer.domElement);
  renderer.domElement.addEventListener('click', ()=>{
    if (mainMenu.style.display==='none' && !isMobile) controls.lock();
  });
  scene.add(controls.getObject());

  scene.add(new THREE.HemisphereLight(0xffffff, 0x40405a, 0.9));
  const sun = new THREE.DirectionalLight(0xffffff, 0.7); sun.position.set(20,40,10); scene.add(sun);

  const texLoader = new THREE.TextureLoader();
  const grass = texLoader.load('assets/textures/grasslight-big.jpg');
  grass.wrapS = grass.wrapT = THREE.RepeatWrapping; grass.anisotropy = 8; if (THREE.SRGBColorSpace) grass.colorSpace = THREE.SRGBColorSpace;
  const brick = texLoader.load('assets/textures/brick_diffuse.jpg');
  brick.wrapS = brick.wrapT = THREE.RepeatWrapping; brick.anisotropy = 8; if (THREE.SRGBColorSpace) brick.colorSpace = THREE.SRGBColorSpace;
  // Quality apply function (after textures are available)
  function applyQuality(level){
    quality = level || quality;
    const isMobile = /Android|iPhone|iPad|iPod|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent)
                      || (('ontouchstart' in window) && window.matchMedia('(max-width: 900px)').matches);
    const baseCap = isMobile ? 1.5 : 2;
    const cap = (quality==='low') ? 1.0 : (quality==='med') ? Math.min(baseCap, 1.5) : baseCap;
    pixelRatioCap = cap;
    const ratio = Math.min(window.devicePixelRatio || 1, pixelRatioCap);
    renderer.setPixelRatio(ratio);
    if (typeof mapRenderer !== 'undefined' && mapRenderer) {
      mapRenderer.setPixelRatio(ratio);
    }
    const maxAniso = renderer.capabilities.getMaxAnisotropy?.() || 8;
    const aniso = (quality==='low') ? Math.min(2, maxAniso) : (quality==='med') ? Math.min(4, maxAniso) : Math.min(8, maxAniso);
    if (grass && 'anisotropy' in grass) grass.anisotropy = aniso;
    if (brick && 'anisotropy' in brick) brick.anisotropy = aniso;
  }
  applyQuality(quality);
  // init size slider label
  setTimeout(()=>{
    sizeMulInput = document.getElementById('sizeMulInput');
    sizeMulLabel = document.getElementById('sizeMulLabel');
    if (sizeMulInput && sizeMulLabel){
      const upd=()=>{ sizeMulLabel.textContent = String(sizeMulInput.value||'1'); };
      sizeMulInput.addEventListener('input', upd); upd();
    }
  },0);

  const floorMat = new THREE.MeshLambertMaterial({ map: grass });
  const wallMat  = new THREE.MeshLambertMaterial({ map: brick });
  const diamondMat = new THREE.MeshLambertMaterial({ color:0x00ffff, emissive:0x003344, emissiveIntensity:0.7 });
  const superDiamondMat = new THREE.MeshLambertMaterial({ color:0x9b59b6, emissive:0x2e0854, emissiveIntensity:0.9 });
  const exitMat = new THREE.MeshLambertMaterial({ color:0x22cc55 });

  const wallGeo = new THREE.BoxGeometry(cellSize, WALL_HEIGHT, cellSize);
  const diamondGeo = new THREE.OctahedronGeometry(1.2, 0);
  const superDiamondGeo = new THREE.IcosahedronGeometry(1.5, 0);

  function generateMaze(w,h){
    if (w%2===0) w++; if (h%2===0) h++;
    const g = Array.from({length:h}, ()=>Array(w).fill(1));
    function carve(x,y){
      g[y][x]=0;
      const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
      for (let i=dirs.length-1;i>0;i--){ const j=randIntM(i+1); [dirs[i],dirs[j]]=[dirs[j],dirs[i]]; }
      for (const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if (nx>0 && ny>0 && nx<w-1 && ny<h-1 && g[ny][nx]===1){
          g[y+dy/2][x+dx/2]=0; carve(nx,ny);
        }
      }
    }
    carve(1,1);
    g[h-2][w-2]=0;
    return g;
  }

  let maze=[], mazeGroup=null, exitMesh=null, exitCell={x:0,y:0};
  let biomeGroup=null, obstacles=null;
  const _tmpObj = new THREE.Object3D();
  function buildMazeMesh(){
    if (mazeGroup) scene.remove(mazeGroup);
    mazeGroup = new THREE.Group(); scene.add(mazeGroup);

    const W = maze[0].length, H = maze.length;

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(W*cellSize, H*cellSize), floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.set((W*cellSize)/2, 0, (H*cellSize)/2);
    floor.material.map.repeat.set(W, H);
    mazeGroup.add(floor);

    let wallCount=0;
    for (let y=0;y<H;y++)
      for (let x=0;x<W;x++) if (maze[y][x]===1) wallCount++;
    if (wallCount>0){
      const inst = new THREE.InstancedMesh(wallGeo, wallMat, wallCount);
      let i=0;
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if (maze[y][x]!==1) continue;
          _tmpObj.position.set((x+0.5)*cellSize, WALL_HEIGHT/2, (y+0.5)*cellSize);
          _tmpObj.rotation.set(0,0,0);
          _tmpObj.updateMatrix();
          inst.setMatrixAt(i++, _tmpObj.matrix);
        }
      }
      inst.instanceMatrix.needsUpdate = true;
      mazeGroup.add(inst);
    }

    const ex=W-2, ey=H-2;
    exitCell = {x:ex, y:ey};
    exitMesh = new THREE.Mesh(new THREE.CylinderGeometry(1.9,1.9,0.35,24), exitMat);
    exitMesh.position.set((ex+0.5)*cellSize, 0.175, (ey+0.5)*cellSize);
    mazeGroup.add(exitMesh);
  }

  function generateObstaclesIfNeeded(){
    const W = maze[0].length, H = maze.length;
    obstacles = Array.from({length:H}, ()=>Array(W).fill(0));
    if (gameMode!=='biomes') return;

    let attempt=0;
    while (attempt<5){
      for (let y=0;y<H;y++) obstacles[y].fill(0);
      // Only trees as static obstacles; no water or stairs
      const pTree=0.08;
      for (let y=1;y<H-1;y++){
        for (let x=1;x<W-1;x++){
          if (maze[y][x]!==0) continue;
          if ((x===1&&y===1) || (x===exitCell.x && y===exitCell.y)) continue;
          const r = rngBiome.float();
          if (r < pTree) { obstacles[y][x]=1; }
        }
      }
      // Place jump pads (type 4): count scales with size multiplier
      let candidates = [];
      for (let y=1;y<H-1;y++){
        for (let x=1;x<W-1;x++){
          if (maze[y][x]!==0) continue;
          if (obstacles[y][x]!==0) continue;
          if ((x===1&&y===1) || (x===exitCell.x && y===exitCell.y)) continue;
          candidates.push({x,y});
        }
      }
      // Shuffle using rngBiome
      for (let i=candidates.length-1;i>0;i--){ const j=rngBiome.int(i+1); const t=candidates[i]; candidates[i]=candidates[j]; candidates[j]=t; }
      const padTarget = Math.max(2, Math.round(2 * sizeMul));
      const padCount = Math.min(padTarget, candidates.length);
      for (let i=0;i<padCount;i++){
        const c = candidates[i]; obstacles[c.y][c.x] = 4;
      }
      if (isReachable()) break;
      attempt++; rngBiome.set((rngBiome.raw() ^ 0x9E3779B9)>>>0);
    }
  }
  function isReachable(){
    const W = maze[0].length, H = maze.length;
    const q=[[1,1]]; let qi=0; const vis=new Set(['1,1']);
    while (qi<q.length){
      const [x,y]=q[qi++];
      if (x===exitCell.x && y===exitCell.y) return true;
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if (nx<0||ny<0||nx>=W||ny>=H) continue;
        if (maze[ny][nx]!==0) continue;
        const ot = obstacles[ny][nx]||0;
        if (ot!==0 && ot!==4) continue; // pads are passable
        const k=nx+','+ny;
        if (!vis.has(k)){ vis.add(k); q.push([nx,ny]); }
      }
    }
    return false;
  }
  function buildBiomeMeshes(){
    if (biomeGroup) scene.remove(biomeGroup);
    biomeGroup = new THREE.Group(); scene.add(biomeGroup);
    if (gameMode!=='biomes') return;

    const trunkMat = new THREE.MeshLambertMaterial({ color:0x8b5a2b });
    const leafMat  = new THREE.MeshLambertMaterial({ color:0x2ecc71 });
    const padMat   = new THREE.MeshLambertMaterial({ color:0x00d0ff, emissive:0x003355, emissiveIntensity:0.8 });

    const W = maze[0].length, H = maze.length;
    for (let y=0;y<H;y++) for (let x=0;x<W;x++){
      const t = obstacles[y][x]; if (!t) continue;
      const cx=(x+0.5)*cellSize, cz=(y+0.5)*cellSize;
      if (t===1){
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.6,2.2,8), trunkMat);
        trunk.position.set(cx, 1.1, cz); biomeGroup.add(trunk);
        const crown = new THREE.Mesh(new THREE.ConeGeometry(1.8, 3.2, 12), leafMat);
        crown.position.set(cx, 3.1, cz); biomeGroup.add(crown);
      }else if (t===4){
        const pad = new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.22,20), padMat);
        pad.position.set(cx, 0.11, cz); biomeGroup.add(pad);
        const ring = new THREE.Mesh(new THREE.TorusGeometry(1.6, 0.08, 8, 32), padMat);
        ring.position.set(cx, 0.3, cz); ring.rotation.x = Math.PI/2; biomeGroup.add(ring);
      }
    }
  }

  let diamondsRef=[], diamonds=[];
  function generateDiamondsRef(){
    const W = maze[0].length, H = maze.length;
    const used = new Set(); diamondsRef=[];
    let tries=0;
    while (diamondsRef.length < DIAMOND_COUNT && tries < 5000){
      tries++;
      const px = rngDiam.int(W), py = rngDiam.int(H);
      const key = px+'_'+py;
      if (maze[py]?.[px]!==0) continue;
      if (obstacles && obstacles[py][px]!==0) continue;
      if ((px===1&&py===1) || (px===exitCell.x&&py===exitCell.y)) continue;
      if (used.has(key)) continue;
      used.add(key);
      const isSuper = rngDiam.float() < SUPER_CHANCE;
      diamondsRef.push({x:px, y:py, type: isSuper?'S':'N'});
    }
    let totalValue = diamondsRef.reduce((s,d)=>s+(d.type==='S'?20:1),0), i=0;
    while (totalValue < toWin + 5 && i<diamondsRef.length){
      if (diamondsRef[i].type==='N'){ diamondsRef[i].type='S'; totalValue+=19; }
      i++;
    }
  }
  function spawnDiamondsFromRef(maskBig){
    diamonds.forEach(d=>scene.remove(d)); diamonds=[];
    for (let i=0;i<diamondsRef.length;i++){
      const bit = (maskBig >> BigInt(i)) & 1n; if (bit===1n) continue;
      const ref = diamondsRef[i];
      const geo = (ref.type==='S') ? superDiamondGeo : diamondGeo;
      const mat = (ref.type==='S') ? superDiamondMat : diamondMat;
      const d = new THREE.Mesh(geo, mat);
      d.userData.idx = i; d.userData.type = ref.type;
      d.position.set((ref.x+0.5)*cellSize, 1.6, (ref.y+0.5)*cellSize);
      scene.add(d); diamonds.push(d);
    }
  }

  /* 3D-–∫–∞—Ä—Ç–∞ */
  mapRenderer = new THREE.WebGLRenderer({ canvas: mapCanvas, alpha:true, antialias:true });
  mapRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, pixelRatioCap));
  mapRenderer.setClearColor(0x000000, 0);
  const mapScene = new THREE.Scene();
  const mapCam = new THREE.PerspectiveCamera(60, 1, 0.1, 5000);
  const mapLight = new THREE.DirectionalLight(0xffffff, 0.9); mapLight.position.set(100,200,100);
  mapScene.add(new THREE.AmbientLight(0xffffff, 0.6)); mapScene.add(mapLight);

  let mapMazeGroup=null, mapDiamonds=[], mapPlayer=null, mapExit=null, mapMice=[], mapPads=[];
  let lastMapMask = null;
  function buildMapScene(){
    if (mapMazeGroup) mapScene.remove(mapMazeGroup);
    mapMazeGroup = new THREE.Group(); mapScene.add(mapMazeGroup);
    mapDiamonds.forEach(m=>mapScene.remove(m)); mapDiamonds=[]; if (mapExit) mapScene.remove(mapExit);

    const W = maze[0].length, H = maze.length;
    const gFloor = new THREE.Mesh(new THREE.PlaneGeometry(W*cellSize, H*cellSize),
      new THREE.MeshLambertMaterial({ color:0x335533 }));
    gFloor.rotation.x = -Math.PI/2; gFloor.position.set((W*cellSize)/2, 0, (H*cellSize)/2);
    mapMazeGroup.add(gFloor);

    const wMat = new THREE.MeshBasicMaterial({ color:0xffffff, wireframe:true });
    let wCount=0;
    for (let y=0;y<H;y++) for (let x=0;x<W;x++) if (maze[y][x]===1) wCount++;
    if (wCount>0){
      const instW = new THREE.InstancedMesh(wallGeo, wMat, wCount);
      let wi=0;
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if (maze[y][x]!==1) continue;
          _tmpObj.position.set((x+0.5)*cellSize, WALL_HEIGHT/2, (y+0.5)*cellSize);
          _tmpObj.rotation.set(0,0,0);
          _tmpObj.updateMatrix();
          instW.setMatrixAt(wi++, _tmpObj.matrix);
        }
      }
      instW.instanceMatrix.needsUpdate = true;
      mapMazeGroup.add(instW);
    }

    // build diamonds once per current mask
    lastMapMask = buildMaskBigInt();
    for (const d of diamonds){
      const m = new THREE.Mesh(
        d.userData.type==='S' ? superDiamondGeo : diamondGeo,
        new THREE.MeshBasicMaterial({ color: d.userData.type==='S' ? 0x9b59b6 : 0x00ffff })
      );
      m.position.copy(d.position); mapScene.add(m); mapDiamonds.push(m);
    }
    mapExit = new THREE.Mesh(new THREE.CylinderGeometry(2,2,0.6,20), new THREE.MeshBasicMaterial({color:0x22cc55}));
    mapExit.position.copy(exitMesh.position); mapScene.add(mapExit);

    if (!mapPlayer){
      mapPlayer = new THREE.Mesh(new THREE.ConeGeometry(2.2, 4, 16), new THREE.MeshBasicMaterial({ color:0xff3333 }));
      mapScene.add(mapPlayer);
    }
    // reset mice markers
    for (const mk of mapMice) mapScene.remove(mk); mapMice=[];
    for (const m of mice){
      const mk = new THREE.Mesh(new THREE.SphereGeometry(1.2, 12, 12), new THREE.MeshBasicMaterial({ color:0xffaa33 }));
      mk.position.copy(m.group.position); mapScene.add(mk); mapMice.push(mk);
    }
    // build pad markers
    for (const pk of mapPads) mapScene.remove(pk); mapPads=[];
    if (obstacles){
      const W = maze[0].length, H = maze.length;
      const mat = new THREE.MeshBasicMaterial({ color:0x00d0ff });
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if ((obstacles[y]?.[x]||0)===4){
            const ring = new THREE.Mesh(new THREE.TorusGeometry(1.8, 0.08, 6, 20), mat);
            ring.position.set((x+0.5)*cellSize, 0.6, (y+0.5)*cellSize);
            ring.rotation.x = Math.PI/2; mapScene.add(ring); mapPads.push(ring);
          }
        }
      }
    }
    // mice markers added above

    const centerX = (W*cellSize)/2, centerZ = (H*cellSize)/2;
    const maxSide = Math.max(W*cellSize, H*cellSize);
    mapCam.position.set(centerX, maxSide*0.9, centerZ);
    mapCam.lookAt(centerX, 0, centerZ);

    const w = mapCanvas.clientWidth || 800, h = mapCanvas.clientHeight || 600;
    mapRenderer.setSize(w, h, false); mapCam.aspect = w/h; mapCam.updateProjectionMatrix();
  }
  function updateMapScene(){
    if (mapCanvas.style.display==='none') return;
    if (mapPlayer){
      const p = controls.getObject().position;
      mapPlayer.position.set(p.x, 3, p.z);
      mapPlayer.rotation.set(0, camera.rotation.y, 0);
    }
    const curMask = buildMaskBigInt();
    if (lastMapMask===null || curMask!==lastMapMask){
      for (const m of mapDiamonds) mapScene.remove(m);
      mapDiamonds = [];
      for (const d of diamonds){
        const m = new THREE.Mesh(
          d.userData.type==='S' ? superDiamondGeo : diamondGeo,
          new THREE.MeshBasicMaterial({ color: d.userData.type==='S' ? 0x9b59b6 : 0x00ffff })
        );
        m.position.copy(d.position); mapScene.add(m); mapDiamonds.push(m);
      }
      lastMapMask = curMask;
    }
    // update mice markers
    for (const mk of mapMice) mapScene.remove(mk); mapMice=[];
    for (const m of mice){
      const mk = new THREE.Mesh(new THREE.SphereGeometry(1.2, 12, 12), new THREE.MeshBasicMaterial({ color:0xffaa33 }));
      mk.position.copy(m.group.position); mapScene.add(mk); mapMice.push(mk);
    }
    mapRenderer.render(mapScene, mapCam);
  }

  /* –°–æ—Å—Ç–æ—è–Ω–∏–µ */
  let diamondCount=0, totalDiamonds=0, levelsCleared=0, mapUnlocked=false;
  let gameMode = 'classic';
  let jumpUnlockedClassic = false;
  // Mice (mob) state
  const mice=[]; const MOUSE_SPEED=8; const MOUSE_HALF_H=0.5;
  let miceCaught=0;
  let mouseModel=null; let objLoader=null; let ratTexture=null;
  async function ensureMouseModel(){
    if (mouseModel) return mouseModel;
    try{
      // Only OBJ loader is used now
      if (!objLoader) objLoader = new OBJLoader();
      if (!ratTexture){
        const tl = new THREE.TextureLoader();
        ratTexture = tl.load('assets/models/rat.jpg');
        if (THREE.SRGBColorSpace) ratTexture.colorSpace = THREE.SRGBColorSpace;
      }
      const obj = await objLoader.loadAsync('assets/models/rat.obj');
      obj.traverse(n=>{
        if (n.isMesh){
          n.material = new THREE.MeshStandardMaterial({ map: ratTexture, roughness:0.85, metalness:0.0 });
        }
      });
      obj.scale.set(0.015,0.015,0.015);
      mouseModel = obj;
      return mouseModel;
    }catch(e2){
      console.warn('OBJ not found, using procedural model');
      mouseModel = null; return null;
    }
  }

  function updateHUD(){
    // counts are updated via textContent, here update perk states/visibility
    const MAP_COST = 20 * sizeMul;
    const JUMP_COST = 10 * sizeMul;
    perkMap.classList.toggle('on', mapUnlocked);
    perkMap.classList.toggle('can', !mapUnlocked && totalDiamonds>=MAP_COST);
    // update price labels
    const priceMap = perkMap.querySelector('.price'); if (priceMap) priceMap.textContent = String(MAP_COST);
    const priceJump = perkJump.querySelector('.price'); if (priceJump) priceJump.textContent = String(JUMP_COST);
    // jump icon only in Classic
    if (gameMode==='classic'){
      perkJump.style.display='flex';
      perkJump.classList.toggle('on', jumpUnlockedClassic);
      perkJump.classList.toggle('can', !jumpUnlockedClassic && totalDiamonds>=JUMP_COST);
    }else{
      perkJump.style.display='none';
    }
    // mice caught
    const miceUI = document.getElementById('miceCaught'); if (miceUI) miceUI.textContent = String(miceCaught);
  }

  function toggleMap(){
    const MAP_COST = 20 * sizeMul;
    if (!mapUnlocked){
      if (totalDiamonds >= MAP_COST){
        totalDiamonds -= MAP_COST; totalUI.textContent = totalDiamonds;
        mapUnlocked = true; updateHUD();
        mapCanvas.style.display='block'; buildMapScene(); return;
      }else{ showToast(`–ù—É–∂–Ω–æ ${MAP_COST} –∞–ª–º–∞–∑–æ–≤ –¥–ª—è –∫–∞—Ä—Ç—ã`, 'warn'); return; }
    }
    if (mapCanvas.style.display==='none'){ mapCanvas.style.display='block'; buildMapScene(); }
    else mapCanvas.style.display='none';
  }

  function blockHeightAt(gx,gz){
    if ((maze[gz]?.[gx])===1) return WALL_HEIGHT;
    if (obstacles){
      const t = obstacles[gz]?.[gx] || 0;
      if (t===1) return 3.6;
      if (t===2) return 0.25;
      if (t===3) return 1.0;
      if (t===4) return 0.0; // jump pad is flat
    }
    return 0;
  }
  function groundHeightAtWorld(x,z){
    return blockHeightAt(Math.floor(x/cellSize), Math.floor(z/cellSize));
  }
  function isBlockedAt(gx,gz,posY){
    const h = blockHeightAt(gx,gz);
    if (h<=0) return false;
    return posY <= h + playerRadius*0.6;
  }

  /* –°–µ–π–≤—ã */
  // Base32 (RFC4648) uppercase alphabet: A-Z2-7
  const B32_ALPH = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
  function b32encode(bytes){
    let out=''; let i=0, buffer=0, bitsLeft=0;
    while(i<bytes.length){ buffer=(buffer<<8)|bytes[i++]; bitsLeft+=8; while(bitsLeft>=5){ bitsLeft-=5; out+=B32_ALPH[(buffer>>bitsLeft)&31]; } }
    if(bitsLeft>0){ out+=B32_ALPH[(buffer<<(5-bitsLeft))&31]; }
    return out;
  }
  function b32decode(str){
    const s=str.replace(/-/g,'').replace(/\s+/g,'');
    let buffer=0,bitsLeft=0, out=[];
    for(const ch of s){ const v=B32_ALPH.indexOf(ch); if(v<0) continue; buffer=(buffer<<5)|v; bitsLeft+=5; if(bitsLeft>=8){ bitsLeft-=8; out.push((buffer>>bitsLeft)&255); } }
    return new Uint8Array(out);
  }
  function clamp(v,min,max){ return v<min?min:v>max?max:v; }
  function getGridPos(){
    const p=controls.getObject().position;
    const gx = Math.max(0, Math.min(15, Math.floor(p.x/cellSize)));
    const gz = Math.max(0, Math.min(15, Math.floor(p.z/cellSize)));
    const fx = Math.max(0, Math.min(15, Math.round(((p.x/cellSize)-gx)*15)));
    const fz = Math.max(0, Math.min(15, Math.round(((p.z/cellSize)-gz)*15)));
    return { gx, gz, fx, fz };
  }
  function buildCollectedList(){
    const collected=[]; const aliveIdx=new Set(diamonds.map(d=>d.userData.idx));
    for (let i=0;i<diamondsRef.length;i++) if (!aliveIdx.has(i)) collected.push(i);
    return collected;
  }
  function maskFromCollectedList(list){ let mask=0n; for(const i of list){ mask |= (1n<<BigInt(i)); } return mask; }
  function encodeSave(){
    const p=controls.getObject().position;
    const save = {
      size:sizeMul,
      mode: gameMode,
      seeds: { maze:mazeSeed, diam:diamondsSeed, biome:biomeSeed },
      pos: { x:+p.x.toFixed(3), y:+p.y.toFixed(3), z:+p.z.toFixed(3), yaw:+((camera.rotation.y)%(Math.PI*2)).toFixed(4), pitch:+(camera.rotation.x).toFixed(4), fly:isFlying },
      progress: { total: totalDiamonds, levels: levelsCleared, map: mapUnlocked, jump: jumpUnlockedClassic, carry: diamondCount },
      collected: buildCollectedList(),
      mice: mice.map(m=>({ gx: Math.floor(m.group.position.x/cellSize), gz: Math.floor(m.group.position.z/cellSize) }))
    };
    const json = JSON.stringify(save);
    const bytes = new TextEncoder().encode(json);
    const b32 = b32encode(bytes).toUpperCase();
    let out=''; for (let i=0;i<b32.length;i++){ out+=b32[i]; if ((i%8)===7 && i<b32.length-1) out+='-'; }
    return out;
  }
  function decodeSave(str){
    const flat = String(str).replace(/-/g,'').toUpperCase();
    const bytes = b32decode(flat);
    const json = new TextDecoder().decode(bytes);
    const d = JSON.parse(json);
    return d;
  }
  function isValidSave(str){
    try{
      const d = decodeSave(str);
      return d && typeof d==='object' && d.size>=1 && d.size<=50 && d.seeds && d.pos && d.progress;
    }catch{ return false; }
  }

  /* –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ / –≥–µ–π–º–ø–ª–µ–π */
  let canExit=false, exitStartT=0, onExitCellLast=false;
  const keys = Object.create(null);

  // Debug state and FPS counters
  let debugOn = false;
  let fps = 0, _fpsAccum = 0, _fpsFrames = 0;

  let velY = 0;
  const GRAV = -25, JUMP_V = 8, JUMP_V_PAD = 16, FLY_V = 10;
  let onGround = true, isFlying = false, lastSpaceTime = 0;
  let buyHold=false, buyStart=0;
  let deathCooldownUntil = 0;

  function isOnJumpPad(){
    if (gameMode!=='biomes' || !obstacles) return false;
    const c = playerCell();
    return (obstacles[c.y]?.[c.x]===4);
  }

  window.addEventListener('keydown', e=>{
    if (mainMenu.style.display !== 'none') return; // ignore gameplay hotkeys in menu
    keys[e.code]=true;

    if (e.code==='KeyM') toggleMap();
    if (e.code==='Digit0'){
      debugOn = !debugOn;
      debugPanel.style.display = debugOn ? 'block' : 'none';
      showToast(debugOn ? 'Debug ON (0)' : 'Debug OFF (0)', debugOn ? 'success' : 'warn');
    }
    if (e.code==='KeyQ'){
      const order=['low','med','high'];
      const idx = order.indexOf(quality);
      applyQuality(order[(idx+1)%order.length]);
      showToast(`–ö–∞—á–µ—Å—Ç–≤–æ: ${quality.toUpperCase()}`, 'success');
    }
    if (e.code==='Digit1'){
      const code=encodeSave();
      copyText(code).then(()=>showToast(`–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: ${code}`, 'success', 2600));
      for (const k in keys) keys[k]=false;
    }
    if (e.code==='Digit2'){
      const code=prompt('–í—Å—Ç–∞–≤—å—Ç–µ –∫–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:');
      if (code) loadFromCode(code.trim());
      for (const k in keys) keys[k]=false;
    }
    if (e.code==='Digit3'){ totalDiamonds+=100; totalUI.textContent=totalDiamonds; updateHUD(); showToast('+100 –∞–ª–º–∞–∑–æ–≤', 'success'); }
    if (e.code==='Digit4'){ goToMainMenu(); }
    if (e.code==='Digit7'){ spawnMouse(true); }

    if (e.code==='Space'){
      if (e.repeat) return;
      const now=performance.now();
      const classicLocked = (gameMode==='classic' && !jumpUnlockedClassic);

      if (classicLocked){
        if (!buyHold){ buyHold = true; buyStart = now; buyRing.style.display='block'; }
        e.preventDefault(); return;
      }

      if (now - lastSpaceTime < 300){
        isFlying = !isFlying;
        if (isFlying){ velY=0; onGround=false; }
      }else{
        if (!isFlying && onGround){ velY = isOnJumpPad() ? JUMP_V_PAD : JUMP_V; onGround=false; }
      }
      lastSpaceTime = now;
    }
  });

  window.addEventListener('keyup', e=>{
    if (mainMenu.style.display !== 'none') return;
    keys[e.code]=false;
    if (e.code==='Space' && buyHold){ buyHold=false; buyRing.style.display='none'; }
  });

  const tileX = x => Math.floor(x / cellSize);
  const tileZ = z => Math.floor(z / cellSize);

  function moveWithCollisions(dx, dz){
    const pos = controls.getObject().position;
    const half = cellSize/2;

    let nx = pos.x + dx;
    let gx = tileX(nx);
    let gz = tileZ(pos.z);
    let cx = (gx + 0.5) * cellSize;
    let offX = nx - cx;

    if (offX < -half + playerRadius) { if (isBlockedAt(gx - 1, gz, pos.y)) nx = cx - half + playerRadius; }
    if (offX >  half - playerRadius) { if (isBlockedAt(gx + 1, gz, pos.y)) nx = cx + half - playerRadius; }
    pos.x = nx;

    let nz = pos.z + dz;
    gx = tileX(pos.x);
    gz = tileZ(nz);
    let cz = (gz + 0.5) * cellSize;
    let offZ = nz - cz;

    if (offZ < -half + playerRadius) { if (isBlockedAt(gx, gz - 1, pos.y)) nz = cz - half + playerRadius; }
    if (offZ >  half - playerRadius) { if (isBlockedAt(gx, gz + 1, pos.y)) nz = cz + half - playerRadius; }
    pos.z = nz;
  }

  const up = new THREE.Vector3(0,1,0), forward = new THREE.Vector3(), right = new THREE.Vector3();
  const v2tmp = new THREE.Vector3();

  function playerCell(){ const p = controls.getObject().position; return { x: Math.floor(p.x/cellSize), y: Math.floor(p.z/cellSize) }; }

  function isPassableCell(x,y){
    if (!maze[y] || maze[y][x]!==0) return false;
    const t = obstacles?.[y]?.[x]||0; return (t===0 || t===4);
  }

  async function spawnMouse(force){
    if (gameMode!=='biomes') return;
    if (!force){ if (rngBiome.float() >= 0.05) return; }
    // pick random passable cell far-ish from player
    const W = maze[0].length, H = maze.length;
    const pc = playerCell();
    const picks = [];
    for (let y=1;y<H-1;y++) for (let x=1;x<W-1;x++){
      if (!isPassableCell(x,y)) continue;
      if ((x===1&&y===1) || (x===exitCell.x && y===exitCell.y)) continue;
      const dx = x-pc.x, dy = y-pc.y; if (dx*dx+dy*dy < 25) continue; // not too close
      picks.push({x,y});
    }
    if (!picks.length) return;
    const p = picks[rngBiome.int(picks.length)];
    let group;
    const base = await ensureMouseModel();
    if (base){ group = base.clone(true); }
    else {
      // improved low-poly backup model
      group = new THREE.Group();
      const bodyMat = new THREE.MeshLambertMaterial({ color:0x9c7b60 });
      const earMat  = new THREE.MeshLambertMaterial({ color:0x6d4c41 });
      const darkMat = new THREE.MeshLambertMaterial({ color:0x2d2a26 });
      const pinkMat = new THREE.MeshLambertMaterial({ color:0xc48a84 });
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.7, 20, 16), bodyMat); body.scale.set(1.4,0.9,2.0); body.position.set(0,0.45,0); group.add(body);
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 14), bodyMat); head.scale.set(1.0,0.9,1.1); head.position.set(0,0.5,0.95); group.add(head);
      const earL = new THREE.Mesh(new THREE.ConeGeometry(0.18,0.22,14), earMat); earL.position.set(-0.22,0.95,0.6); earL.rotation.x = Math.PI; group.add(earL);
      const earR = earL.clone(); earR.position.x*=-1; group.add(earR);
      const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 8), darkMat); eyeL.position.set(-0.14,0.56,1.12); group.add(eyeL);
      const eyeR = eyeL.clone(); eyeR.position.x*=-1; group.add(eyeR);
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 8), pinkMat); nose.position.set(0,0.48,1.3); group.add(nose);
      const whiskerMat = new THREE.MeshLambertMaterial({ color:0xdddddd });
      const whisk1 = new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.01,0.6,6), whiskerMat); whisk1.position.set(0.25,0.48,1.22); whisk1.rotation.z = Math.PI/8; whisk1.rotation.x = Math.PI/2; group.add(whisk1);
      const whisk2 = whisk1.clone(); whisk2.position.x = -0.25; whisk2.rotation.z = -Math.PI/8; group.add(whisk2);
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.05,1.6,10), pinkMat); tail.position.set(0,0.55,-1.05); tail.rotation.x = Math.PI/3; group.add(tail);
      const legGeo = new THREE.CylinderGeometry(0.05,0.06,0.25,8);
      for (const sx of [-0.25,0.25]){
        const l1 = new THREE.Mesh(legGeo, darkMat); l1.position.set(sx,0.2,0.2); group.add(l1);
        const l2 = new THREE.Mesh(legGeo, darkMat); l2.position.set(sx,0.2,-0.2); group.add(l2);
      }
    }
    group.position.set((p.x+0.5)*cellSize, MOUSE_HALF_H, (p.y+0.5)*cellSize);
    scene.add(group);
    mice.push({ group, target:null, lastCell:{x:p.x,y:p.y}, velY:0, onGround:true, onWall:false, loot:0 });
    showToast('–ü–æ—è–≤–∏–ª–∞—Å—å –º—ã—à—å! –ó–∞–≥–æ–Ω–∏—Ç–µ –µ—ë –≤ —Ç—É–ø–∏–∫', 'success');
  }
  function updateMice(dt){
    if (!mice.length) return;
    const pos = controls.getObject().position;
    for (let i=mice.length-1;i>=0;i--){
      const m = mice[i];
      const dx = pos.x - m.group.position.x, dz = pos.z - m.group.position.z;
      if ((dx*dx + dz*dz) < 2.56){
        const reward = 50 + m.loot;
        diamondCount += reward; totalDiamonds += reward; miceCaught++;
        diamondUI.textContent=diamondCount; totalUI.textContent=totalDiamonds; updateHUD();
        scene.remove(m.group); mice.splice(i,1); showToast(`+${reward} –∑–∞ –º—ã—à—å`, 'success');
        continue;
      }
      const mc = { x: Math.floor(m.group.position.x / cellSize), y: Math.floor(m.group.position.z / cellSize) };
      const centerX = (mc.x+0.5)*cellSize, centerZ=(mc.y+0.5)*cellSize;
      const atCenter = (Math.abs(m.group.position.x - centerX) < 0.05 && Math.abs(m.group.position.z - centerZ) < 0.05);
      if (atCenter || !m.target){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        let best=null, bestDist=-1;
        for (const [dx,dy] of dirs){
          const nx=mc.x+dx, ny=mc.y+dy;
          if (!(m.onWall ? true : isPassableCell(nx,ny))) continue;
          if (m.lastCell && nx===m.lastCell.x && ny===m.lastCell.y) continue;
          const cx=(nx+0.5)*cellSize, cz=(ny+0.5)*cellSize;
          const d2 = (cx-pos.x)*(cx-pos.x) + (cz-pos.z)*(cz-pos.z);
          if (d2>bestDist){ bestDist=d2; best={x:nx,y:ny}; }
        }
        if (!best && m.lastCell){ best = {x:m.lastCell.x, y:m.lastCell.y}; }
        if (best){ m.target = best; m.lastCell = mc; }
      }
      if (m.target){
        const tx=(m.target.x+0.5)*cellSize, tz=(m.target.y+0.5)*cellSize;
        const dirx = tx - m.group.position.x, dirz = tz - m.group.position.z;
        const len = Math.hypot(dirx, dirz) || 1;
        const step = Math.min(len, MOUSE_SPEED*dt);
        m.group.position.x += (dirx/len)*step;
        m.group.position.z += (dirz/len)*step;
        m.group.rotation.y = Math.atan2(dirx, dirz);
      }
      // vertical physics & pad/wall logic
      const gx = Math.floor(m.group.position.x/cellSize), gz = Math.floor(m.group.position.z/cellSize);
      const cellH = blockHeightAt(gx,gz);
      const groundY = (m.onWall && cellH>0) ? (cellH + MOUSE_HALF_H) : (groundHeightAtWorld(m.group.position.x, m.group.position.z) + MOUSE_HALF_H);
      m.velY += GRAV * dt;
      m.group.position.y += m.velY * dt;
      if (m.group.position.y <= groundY){
        m.group.position.y = groundY; m.velY = 0; m.onGround = true;
        if ((obstacles?.[gz]?.[gx]||0)===4){ m.velY = JUMP_V_PAD; m.onGround=false; m.onWall=true; }
        if (cellH<=0 && m.onWall){ m.onWall=false; }
      }
      if (m.group.position.y < MOUSE_HALF_H) m.group.position.y = MOUSE_HALF_H;

      // Mice pick up diamonds
      if (diamonds.length){
        diamonds = diamonds.filter(d=>{
          if (m.group.position.distanceToSquared(d.position) < 2.56){
            const val = (d.userData.type==='S') ? 20 : 1;
            m.loot += val; scene.remove(d); return false;
          }
          return true;
        });
      }
    }
  }

  function setView(yaw, pitch){
    camera.rotation.order = 'YXZ';
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;
    camera.rotation.z = 0;
  }

  function onVictory(){
    mapCanvas.style.display='none';
    levelsCleared++; levelsUI.textContent = levelsCleared;
    if (gameMode==='classic') jumpUnlockedClassic=false;
    updateHUD();
    showToast(`–ü–æ–±–µ–¥–∞! –ü—Ä–∏–Ω–µ—Å–µ–Ω–æ: ${diamondCount}. –£—Ä–æ–≤–Ω–∏: ${levelsCleared}`, 'success', 2600);
    resetRun();
  }

  function killAndRespawn(){
    const now = performance.now();
    deathCooldownUntil = now + 1000;
    diamondCount = 0; diamondUI.textContent = diamondCount;
    isFlying = false; velY=0; onGround=true;
    controls.getObject().position.set((1+0.5)*cellSize, 2, (1+0.5)*cellSize);
    setView(0,0);
    mapCanvas.style.display='none';
    showToast('–í—ã —É–ø–∞–ª–∏ –∑–∞ –∫—Ä–∞–π. –í–æ–∑–≤—Ä–∞—Ç –∫ –Ω–∞—á–∞–ª—É.', 'warn', 2400);
  }

  function updateBuyRing(){
    const JUMP_COST = 10 * sizeMul;
    if (!buyHold){ buyRing.style.display='none'; return; }
    if (gameMode!=='classic' || jumpUnlockedClassic){ buyRing.style.display='none'; buyHold=false; return; }
    const need=JUMP_COST;
    if (totalDiamonds < need){
      buyRing.style.display='none'; buyHold=false;
      showToast(`–ù—É–∂–Ω–æ ${need} –∞–ª–º–∞–∑–æ–≤ –¥–ª—è –ø—Ä—ã–∂–∫–æ–≤`, 'warn'); return;
    }
    const prog = Math.min(1, (performance.now()-buyStart)/5000);
    const deg = Math.floor(prog*360);
    buyRing.style.display='block';
    buyRing.style.background = `conic-gradient(#44ff77 ${deg}deg, rgba(255,255,255,0.12) ${deg}deg 360deg)`;
    if (prog>=1){
      totalDiamonds -= need; totalUI.textContent=totalDiamonds;
      jumpUnlockedClassic = true;
      buyRing.style.display='none'; buyHold=false;
      updateHUD();
      showToast('–ü—Ä—ã–∂–∫–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ —ç—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å', 'success');
    }
  }

  const clock = new THREE.Clock();

  /* –ú–æ–±–∏–ª—å–Ω—ã–µ –æ—Å–∏/–≤–∑–≥–ª—è–¥ ‚Äî Minecraft-–ø–æ–¥–æ–±–Ω–æ */
  let mobAx=0, mobAz=0;               // -1..1
  let lookId=null, lookLastX=0, lookLastY=0;
  let stickId=null, stickCX=0, stickCY=0, stickR=70;

  function setMobileUIVisible(show){ mobileUI.style.display = show ? 'block' : 'none'; }

  const stickRect = ()=>stickL.getBoundingClientRect();
  stickL.addEventListener('touchstart', (e)=>{
    for (const t of e.changedTouches){
      if (stickId===null){
        stickId = t.identifier;
        const b=stickRect(); stickCX=b.left+b.width/2; stickCY=b.top+b.height/2;
        stickKnob.style.left='50%'; stickKnob.style.top='50%';
        e.preventDefault(); break;
      }
    }
  }, {passive:false});
  stickL.addEventListener('touchmove', (e)=>{
    for (const t of e.changedTouches){
      if (t.identifier!==stickId) continue;
      const dx=t.clientX-stickCX, dy=t.clientY-stickCY;
      const len=Math.hypot(dx,dy); const max=stickR-20;
      const k = len>max ? max/len : 1;
      const nx=dx*k, ny=dy*k;
      stickKnob.style.left = `calc(50% + ${nx}px)`;
      stickKnob.style.top  = `calc(50% + ${ny}px)`;
      mobAx =  nx/max;
      mobAz = -ny/max;
      e.preventDefault();
    }
  }, {passive:false});
  function stickRelease(){ stickId=null; mobAx=0; mobAz=0; stickKnob.style.left='50%'; stickKnob.style.top='50%'; }
  stickL.addEventListener('touchend',   (e)=>{ for (const t of e.changedTouches){ if (t.identifier===stickId){ stickRelease(); break; } } }, {passive:false});
  stickL.addEventListener('touchcancel',(e)=>{ for (const t of e.changedTouches){ if (t.identifier===stickId){ stickRelease(); break; } } }, {passive:false});

  function isOnControls(el){ return el.closest('#stickL') || el.closest('.mobBtns'); }
  lookPad.addEventListener('touchstart',(e)=>{
    for (const t of e.changedTouches){
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (isOnControls(el)) continue;
      if (lookId===null){ lookId=t.identifier; lookLastX=t.clientX; lookLastY=t.clientY; e.preventDefault(); break; }
    }
  }, {passive:false});
  lookPad.addEventListener('touchmove',(e)=>{
    for (const t of e.changedTouches){
      if (t.identifier!==lookId) continue;
      const dx=t.clientX-lookLastX, dy=t.clientY-lookLastY;
      lookLastX=t.clientX; lookLastY=t.clientY;
      const sens = 0.0034;
      let yaw = camera.rotation.y - dx*sens;
      let pitch = camera.rotation.x - dy*sens;
      const limit = Math.PI*0.49;
      if (pitch < -limit) pitch = -limit;
      if (pitch >  limit) pitch =  limit;
      setView(yaw, pitch);
      e.preventDefault(); break;
    }
  }, {passive:false});
  function lookRelease(){ lookId=null; }
  lookPad.addEventListener('touchend',   (e)=>{ for (const t of e.changedTouches){ if (t.identifier===lookId){ lookRelease(); break; } } }, {passive:false});
  lookPad.addEventListener('touchcancel',(e)=>{ for (const t of e.changedTouches){ if (t.identifier===lookId){ lookRelease(); break; } } }, {passive:false});

  // –ö–Ω–æ–ø–∫–∏
  let tapTime=0;
  const mobClassicLocked=()=> (gameMode==='classic' && !jumpUnlockedClassic);
  btnJump.addEventListener('touchstart',(e)=>{
    e.preventDefault();
    if (mobClassicLocked()){
      if (!buyHold){ buyHold=true; buyStart=performance.now(); buyRing.style.display='block'; }
      return;
    }
    const now=performance.now();
    if (now - tapTime < 300){
      isFlying = !isFlying; if (isFlying){ velY=0; onGround=false; }
    }else{
      if (!isFlying && onGround){ velY = isOnJumpPad() ? JUMP_V_PAD : JUMP_V; onGround=false; }
    }
    tapTime=now; keys['Space']=true;
  }, {passive:false});
  btnJump.addEventListener('touchend',()=>{ keys['Space']=false; if (buyHold){ buyHold=false; buyRing.style.display='none'; } });

  btnDown.addEventListener('touchstart',(e)=>{ e.preventDefault(); keys['ShiftLeft']=true; }, {passive:false});
  btnDown.addEventListener('touchend',  ()=>{ keys['ShiftLeft']=false; });

  btnMapBtn.addEventListener('touchstart',(e)=>{ e.preventDefault(); toggleMap(); }, {passive:false});
  btnSave.addEventListener('touchstart',async (e)=>{
    e.preventDefault(); const code=encodeSave();
    menuInput.value = code; await copyText(code); showToast(`–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: ${code}`,'success',2600);
  }, {passive:false});
  btnMenu.addEventListener('touchstart',(e)=>{ e.preventDefault(); goToMainMenu(); }, {passive:false});

  // –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
  async function toggleFullscreen(){
    try{
      if (!document.fullscreenElement){
        const el=document.documentElement;
        await (el.requestFullscreen?.() || el.webkitRequestFullscreen?.call(el));
      }else{
        await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
      }
    }catch(err){ console.warn(err); showToast('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º', 'err'); }
  }
  btnFS.addEventListener('touchstart',(e)=>{ e.preventDefault(); toggleFullscreen(); }, {passive:false});

  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.033, clock.getDelta());

    // FPS accumulation
    _fpsFrames++; _fpsAccum += dt;
    if (_fpsAccum >= 0.5){ fps = Math.round(_fpsFrames / _fpsAccum); _fpsFrames = 0; _fpsAccum = 0; }

    let ax=0, az=0;
    if (keys['KeyW']) az += 1;
    if (keys['KeyS']) az -= 1;
    if (keys['KeyA']) ax -= 1;
    if (keys['KeyD']) ax += 1;
    ax += mobAx; az += mobAz;

    if (ax||az){
      camera.getWorldDirection(forward);
      forward.y=0; forward.normalize();
      right.copy(forward).cross(up).normalize();

      const len = Math.hypot(ax,az) || 1;
      const speed = 9 * dt / len;
      const dx = (right.x*ax + forward.x*az) * speed;
      const dz = (right.z*ax + forward.z*az) * speed;
      moveWithCollisions(dx, dz);
    }

    const pos = controls.getObject().position;

    updateBuyRing();

    const classicLocked = (gameMode==='classic' && !jumpUnlockedClassic);
    const canFlyNow = !classicLocked;
    if (isFlying && !canFlyNow){ isFlying=false; }

    if (isFlying){
      let vy=0;
      if (keys['Space']) vy += FLY_V;
      if (keys['ShiftLeft']||keys['ShiftRight']) vy -= FLY_V;
      pos.y += vy * dt;
      if (pos.y < 2){ pos.y = 2; }
      onGround=false; velY=0;
    }else{
      velY += GRAV * dt;
      pos.y += velY * dt;

      const gH = groundHeightAtWorld(pos.x, pos.z);
      const groundY = gH + 2;
      if (pos.y <= groundY){
        pos.y = groundY; velY=0; onGround=true;
        // Trigger pad jump on stepping on pad
        if (gameMode==='biomes' && isOnJumpPad()){
          velY = JUMP_V_PAD;
          onGround = false;
        }
      }
      if (pos.y < 2){ pos.y = 2; velY=0; onGround=true; }
    }

    const W = maze[0].length*cellSize, H = maze.length*cellSize;
    const now = performance.now();
    if (now > deathCooldownUntil){
      if (pos.x< -0.5 || pos.z< -0.5 || pos.x>W+0.5 || pos.z>H+0.5){
        killAndRespawn();
      }
    }
    pos.x = Math.max(0.25, Math.min(W-0.25, pos.x));
    pos.z = Math.max(0.25, Math.min(H-0.25, pos.z));

    diamonds = diamonds.filter(d=>{
      if (pos.distanceToSquared(d.position) < 2.56){
        const val = (d.userData.type==='S') ? 20 : 1;
        diamondCount += val; totalDiamonds += val;
        diamondUI.textContent=diamondCount; totalUI.textContent=totalDiamonds; updateHUD();
        scene.remove(d); return false;
      }
      return true;
    });

    const c = playerCell();
    const onExit = (c.x===exitCell.x && c.y===exitCell.y);
    const enough = (diamondCount>=toWin);
    if (onExit){
      if (!onExitCellLast){ exitStartT = performance.now(); }
      if (!enough){
        exitWarn.style.display='block';
        exitRing.style.display='none';
      } else {
        exitWarn.style.display='none';
        exitRing.style.display='block';
        const prog = Math.min(1, (performance.now()-exitStartT)/5000);
        const deg = Math.floor(prog*360);
        exitRing.style.background = `conic-gradient(#44ff77 ${deg}deg, rgba(255,255,255,0.12) ${deg}deg 360deg)`;
        if (prog>=1){ exitRing.style.display='none'; onVictory(); }
      }
    } else {
      exitWarn.style.display='none';
      exitRing.style.display='none';
    }
    onExitCellLast = onExit;

    renderer.render(scene, camera);
    updateMice(dt);
    if (debugOn){
      const p = controls.getObject().position;
      const c = playerCell();
      const info = renderer.info;
      debugPanel.textContent =
        `FPS: ${fps} | Quality: ${quality}\n`+
        `DrawCalls: ${info.render.calls}  Tris: ${info.render.triangles}  Lines: ${info.render.lines}  Points: ${info.render.points}\n`+
        `Pos: ${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)}  Cell: ${c.x}, ${c.y}\n`+
        `Mode: ${gameMode}  Flying: ${isFlying}  Ground: ${onGround}  velY: ${velY.toFixed(2)}\n`+
        `Diamonds: carry ${diamondCount} / total ${totalDiamonds}  Levels: ${levelsCleared}  Mice: ${mice.length}\n`+
        `Seeds: maze ${mazeSeed}  diam ${diamondsSeed}  biome ${biomeSeed}  Map: ${mapUnlocked}  Jump: ${jumpUnlockedClassic}`;
    }
    updateMapScene();
  }

  function resetRun(newMazeSeed){
    if (newMazeSeed!=null) reseedMaze(newMazeSeed); else reseedMaze((Math.random()*0x07FF)|0);
    reseedDiam((Math.random()*0x07FF)|0);
    if (gameMode==='biomes') reseedBiome((Math.random()*0x07FF)|0);
    mapUnlocked = false;
    if (gameMode==='classic') jumpUnlockedClassic=false;

    // apply scaling
    mazeSize = BASE_MAZE_SIZE * sizeMul;
    toWin = BASE_TO_WIN * sizeMul;
    DIAMOND_COUNT = BASE_DIAMOND_COUNT * sizeMul;

    maze = generateMaze(mazeSize, mazeSize);
    buildMazeMesh();
    generateObstaclesIfNeeded();
    buildBiomeMeshes();
    generateDiamondsRef();
    spawnDiamondsFromRef(0n);
    // 5% chance to spawn mouse on a new level in biomes
    spawnMouse(false);

    diamondCount = 0; diamondUI.textContent=diamondCount;
    totalUI.textContent = totalDiamonds; levelsUI.textContent = levelsCleared;
    modeUI.textContent = (gameMode==='biomes'?'Biomes':'Classic');

    controls.getObject().position.set((1+0.5)*cellSize, 2, (1+0.5)*cellSize);
    setView(0, 0);

    updateHUD();
    if (mapCanvas.style.display!=='none') buildMapScene();
  }

  function recalcCarryFromMask(mask){
    let sum=0;
    for (let i=0;i<diamondsRef.length;i++){
      if (((mask>>BigInt(i))&1n)===1n){
        sum += (diamondsRef[i].type==='S')?20:1;
      }
    }
    return sum;
  }

  async function loadFromCode(str){
    try{
      const d = decodeSave(str);

      gameMode = (d.mode==='biomes') ? 'biomes' : 'classic';
      sizeMul = clamp(parseInt(d.size||1,10),1,50);
      const seeds = d.seeds||{};
      reseedMaze(seeds.maze||mazeSeed); reseedDiam(seeds.diam||diamondsSeed); reseedBiome(seeds.biome||biomeSeed);
      // apply size before generating
      sizeMul = d.size || 1;
      mazeSize = BASE_MAZE_SIZE * sizeMul;
      toWin = BASE_TO_WIN * sizeMul;
      DIAMOND_COUNT = BASE_DIAMOND_COUNT * sizeMul;

      // reset data structures
      for (const m of mice){ try{ scene.remove(m.group); }catch{} }
      mice.length = 0;

      maze = generateMaze(mazeSize, mazeSize);
      buildMazeMesh();
      generateObstaclesIfNeeded();
      buildBiomeMeshes();
      generateDiamondsRef();
      spawnDiamondsFromRef(d.mask);

      totalDiamonds  = d.total;
      levelsCleared  = d.levels;
      mapUnlocked    = d.map;
      jumpUnlockedClassic = (gameMode==='classic') ? d.jump : false;

      const collected = Array.isArray(d.collected)? d.collected : [];
      spawnDiamondsFromRef(maskFromCollectedList(collected));
      diamondCount = collected.reduce((s,i)=>{
        const t = diamondsRef[i]?.type; return s + (t==='S'?20:1);
      },0);

      diamondUI.textContent=diamondCount; totalUI.textContent=totalDiamonds; levelsUI.textContent=levelsCleared;
      modeUI.textContent = (gameMode==='biomes'?'Biomes':'Classic');

      const pos = d.pos||{};
      controls.getObject().position.set(pos.x||((1+0.5)*cellSize), Math.max(2, pos.y||2), pos.z||((1+0.5)*cellSize));
      setView(pos.yaw||0, clamp(pos.pitch||0, -Math.PI*0.49, Math.PI*0.49));
      isFlying = !!pos.fly && (gameMode!=='classic' || jumpUnlockedClassic);
      velY=0; onGround = !isFlying && (controls.getObject().position.y<=2.01);

      // spawn mice from save
      if (gameMode==='biomes' && d.mice && d.mice.length){
        await ensureMouseModel();
        for (const m of d.mice){
          const gx = clamp(parseInt(m.gx||0,10),0,maze[0].length-1);
          const gz = clamp(parseInt(m.gz||0,10),0,maze.length-1);
          if (isPassableCell(gx, gz)){
            let group;
            if (mouseModel) group = mouseModel.clone(true); else {
              group = new THREE.Group();
              const bodyMat = new THREE.MeshLambertMaterial({ color:0x9c7b60 });
              const earMat  = new THREE.MeshLambertMaterial({ color:0x6d4c41 });
              const darkMat = new THREE.MeshLambertMaterial({ color:0x2d2a26 });
              const pinkMat = new THREE.MeshLambertMaterial({ color:0xc48a84 });
              const body = new THREE.Mesh(new THREE.SphereGeometry(0.7, 20, 16), bodyMat); body.scale.set(1.4,0.9,2.0); body.position.set(0,0.45,0); group.add(body);
              const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 14), bodyMat); head.scale.set(1.0,0.9,1.1); head.position.set(0,0.5,0.95); group.add(head);
              const earL = new THREE.Mesh(new THREE.ConeGeometry(0.18,0.22,14), earMat); earL.position.set(-0.22,0.95,0.6); earL.rotation.x = Math.PI; group.add(earL);
              const earR = earL.clone(); earR.position.x*=-1; group.add(earR);
              const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 8), darkMat); eyeL.position.set(-0.14,0.56,1.12); group.add(eyeL);
              const eyeR = eyeL.clone(); eyeR.position.x*=-1; group.add(eyeR);
              const nose = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 8), pinkMat); nose.position.set(0,0.48,1.3); group.add(nose);
              const whiskerMat = new THREE.MeshLambertMaterial({ color:0xdddddd });
              const whisk1 = new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.01,0.6,6), whiskerMat); whisk1.position.set(0.25,0.48,1.22); whisk1.rotation.z = Math.PI/8; whisk1.rotation.x = Math.PI/2; group.add(whisk1);
              const whisk2 = whisk1.clone(); whisk2.position.x = -0.25; whisk2.rotation.z = -Math.PI/8; group.add(whisk2);
              const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.05,1.6,10), pinkMat); tail.position.set(0,0.55,-1.05); tail.rotation.x = Math.PI/3; group.add(tail);
              const legGeo = new THREE.CylinderGeometry(0.05,0.06,0.25,8);
              for (const sx of [-0.25,0.25]){
                const l1 = new THREE.Mesh(legGeo, darkMat); l1.position.set(sx,0.2,0.2); group.add(l1);
                const l2 = new THREE.Mesh(legGeo, darkMat); l2.position.set(sx,0.2,-0.2); group.add(l2);
              }
            }
            group.position.set((gx+0.5)*cellSize, MOUSE_HALF_H, (gz+0.5)*cellSize);
            scene.add(group);
            mice.push({ group, target:null, lastCell:{x:gx,y:gz}, velY:0, onGround:true, onWall:false, loot:0 });
          }
        }
      }

      for (const k in keys) keys[k]=false;
      updateHUD();
      showToast('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ', 'success');

      if (mapCanvas.style.display!=='none') buildMapScene();
    }catch(e){
      console.error(e);
      showToast('–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –∫–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', 'err', 2800);
    }
  }

  function startNew(mode){
    gameMode = mode;
    // read size multiplier from menu
    sizeMulInput = sizeMulInput || document.getElementById('sizeMulInput');
    const val = parseInt((sizeMulInput?.value||'1'),10);
    sizeMul = isFinite(val)?Math.max(1, Math.min(50, val)):1;
    totalDiamonds=0; diamondCount=0; levelsCleared=0; mapUnlocked=false; miceCaught=0;
    jumpUnlockedClassic = false;
    resetRun();
    mainMenu.style.display='none';
    setMobileUIVisible(isMobile);
    animate();
    showToast(`–†–µ–∂–∏–º: ${mode==='biomes'?'Biomes':'Classic'}`, 'success');
  }

  function goToMainMenu(){
    const code = encodeSave();
    menuInput.value = code;
    try{ controls.unlock && controls.unlock(); }catch{}
    mapCanvas.style.display='none';
    mainMenu.style.display='';
    setMobileUIVisible(false);
    buyRing.style.display='none';
    showToast('–ú–µ–Ω—é. –ö–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω.', 'warn');
  }

  // === –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ===
  btnClassic.addEventListener('click', ()=>startNew('classic'));
  btnBiomes.addEventListener('click',   ()=>startNew('biomes'));
  btnContinue.addEventListener('click', async ()=>{
    const code = menuInput.value.trim();
    if (!code){ showToast('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥', 'warn'); return; }
    if (!isValidSave(code)){ showToast('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∫–æ–¥ ‚Äî –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞', 'err', 3000); return; }
    mainMenu.style.display='none';
    await loadFromCode(code);
    setMobileUIVisible(isMobile);
    animate();
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (mapCanvas.style.display!=='none'){
      const w = mapCanvas.clientWidth, h = mapCanvas.clientHeight;
      mapRenderer.setSize(w, h, false);
      mapCam.aspect = w/h; mapCam.updateProjectionMatrix();
    }
  });

  // —Å—Ç–∞—Ä—Ç –≤ –º–µ–Ω—é
})();
</script>
</body>
</html>
