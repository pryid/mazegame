<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>3D Maze Diamond Hunt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    /* ===== HUD ===== */
    #overlay{
      position:fixed;top:10px;left:10px;z-index:10;
      font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;color:#fff;pointer-events:none;
    }
    #hud{display:flex;align-items:center;gap:10px;background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.2);border-radius:12px;padding:8px 10px}
    .pill{
      display:flex;align-items:center;gap:6px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.18);border-radius:999px;padding:6px 10px
    }
    .pill span{font-weight:700;min-width:24px;text-align:right}
    .ico{width:18px;height:18px;display:block}
    .blue{fill:#00d0ff}
    .gray{fill:#a9b3c4}
    .green{fill:#6cff8f}
    #perks{display:flex;gap:8px;margin-left:6px}
    .perk{
      position:relative;width:28px;height:28px;border-radius:8px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);
      display:flex;align-items:center;justify-content:center;opacity:.55
    }
    .perk.on{opacity:1;border-color:rgba(90,255,120,.6);box-shadow:0 0 0 2px rgba(90,255,120,.2) inset}
    .perk.can{opacity:.9;border-color:rgba(120,180,255,.7);box-shadow:0 0 0 2px rgba(120,180,255,.2) inset}
    .perk .price{
      position:absolute;bottom:-8px;right:-6px;font:10px/1.1 system-ui,Segoe UI,Roboto,Arial,sans-serif;
      background:rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.25);color:#fff;padding:1px 4px;border-radius:6px
    }
    .perk.on .price{display:none}
    #modeText{display:none} /* оставляем для совместимости кода */
    /* ===== Map/View & rings ===== */
    #map3d{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      width:min(90vw,900px);height:min(70vh,650px);display:none;z-index:20;border-radius:12px;background:transparent
    }
    #exitRing, #buyRing{
      position:fixed;left:50%;bottom:26px;transform:translateX(-50%);
      width:84px;height:84px;border-radius:50%;
      background:conic-gradient(#44ff77 0deg, rgba(255,255,255,0.12) 0deg 360deg);
      border:3px solid rgba(255,255,255,0.35);
      box-shadow:0 8px 28px rgba(0,0,0,.5);
      display:none;z-index:25
    }
    #buyRing:after{
      content:"Покупка прыжка (10)"; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      color:#fff; font:12px/1.1 system-ui,Segoe UI,Roboto,Arial,sans-serif; text-align:center; width:76px
    }
    #exitWarn{
      position:fixed;left:50%;bottom:120px;transform:translateX(-50%);
      color:#fff;background:rgba(0,0,0,.6);padding:8px 12px;border-radius:8px;font:14px system-ui,Segoe UI,Roboto,Arial,sans-serif;
      display:none;z-index:25
    }
    /* ===== Main menu ===== */
    #mainMenu{
      position:fixed;inset:0;background:linear-gradient(135deg,#0b0f1a, #182033);
      color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;z-index:100;display:flex;align-items:center;justify-content:center;
    }
    #menuCard{
      width:min(92vw,720px);background:rgba(255,255,255,0.06);backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,0.15);border-radius:14px;padding:20px 24px;box-shadow:0 20px 60px rgba(0,0,0,.5)
    }
    #menuCard h1{margin:0 0 10px 0;font-size:28px}
    #menuCard p{margin:6px 0 14px 0;color:#cfd8ff}
    .menuRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .btn{
      padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.08);color:#fff;cursor:pointer;font-weight:600
    }
    .btn:hover{background:rgba(255,255,255,0.14)}
    .input{
      flex:1;min-width:260px;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.35);color:#fff;outline:none
    }
    /* ===== Toasts ===== */
    #toastWrap{
      position:fixed;left:50%;top:18px;transform:translateX(-50%);
      display:flex;flex-direction:column;gap:8px;z-index:200;pointer-events:none
    }
    .toast{
      background:rgba(0,0,0,.7);color:#fff;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.2);
      font:14px system-ui,Segoe UI,Roboto,Arial,sans-serif; opacity:0; transform:translateY(-8px);
      transition:opacity .2s ease, transform .2s ease; pointer-events:none; max-width:86vw
    }
    .toast.show{opacity:1; transform:translateY(0)}
    .toast.success{border-color:rgba(90,255,120,.5)}
    .toast.warn{border-color:rgba(255,230,90,.6)}
    .toast.err{border-color:rgba(255,120,120,.6)}
    /* ===== Mobile UI ===== */
    #mobileUI{display:none;position:fixed;inset:0;pointer-events:none;z-index:30}
    #lookPad{position:fixed;inset:0;pointer-events:auto;touch-action:none}
    .stickWrap{
      position:absolute;left:14px;bottom:14px;width:140px;height:140px;border-radius:50%;
      background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.15);pointer-events:auto;touch-action:none
    }
    .stickKnob{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,0.25);border:1px solid rgba(255,255,255,0.35)
    }
    .mobBtns{position:absolute;right:14px;bottom:14px;display:flex;flex-direction:column;gap:10px;pointer-events:auto}
    .mobBtn{
      min-width:100px;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.35);color:#fff;text-align:center;font-weight:700
    }
    .mobRow{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    /* Responsive menu text with controls */
    @media (max-width:720px){
      #menuCard{width:92vw}
      .menuRow{flex-direction:column}
      .input{min-width:unset;width:100%}
      .btn{width:100%}
    }
  </style>
</head>
<body>
  <!-- Главное меню -->
  <div id="mainMenu">
    <div id="menuCard">
      <h1>Maze Diamond Hunt</h1>
      <p>Вставьте код сохранения и продолжите, или начните новый забег: классический / с биомами и препятствиями.</p>
      <div class="menuRow">
        <input id="menuSaveInput" class="input" placeholder="Код сохранения (v8)" />
        <button id="btnContinue" class="btn">Продолжить по коду</button>
      </div>
      <div class="menuRow">
        <button id="btnClassic" class="btn">Новый забег — Классический</button>
        <button id="btnBiomes" class="btn">Новый забег — Биомы</button>
      </div>
      <p style="margin-top:16px;font-size:12px;opacity:.85">
        Управление (ПК): клик по игре — захват мыши; WASD — ходьба; Space — прыжок; двойной Space — полёт; Shift — снижение;
        M — 3D-карта (1 покупка за 20 на уровень); 0 — отладка (FPS/метрики); Q — качество (LOW/MED/HIGH);
        1 — сохранить; 2 — загрузить; 3 — +100; 4 — меню.
        На мобильных: левый стик (ходьба), свайп справа (взгляд), «Прыжок/Снижение», «Карта», «Сохранить», «На весь экран», «Меню».
      </p>
    </div>
  </div>

  <!-- HUD: только иконки-счётчики и статусы -->
  <div id="overlay">
    <div id="hud">
      <!-- carried -->
      <div class="pill" title="Алмазы при себе">
        <svg class="ico blue" viewBox="0 0 18 18"><polygon points="9,1 17,9 9,17 1,9"/></svg>
        <span id="diamondCount">0</span>
      </div>
      <!-- total -->
      <div class="pill" title="Алмазы всего">
        <svg class="ico gray" viewBox="0 0 18 18"><polygon points="9,1 17,9 9,17 1,9"/></svg>
        <span id="totalDiamonds">0</span>
      </div>
      <!-- levels -->
      <div class="pill" title="Пройдено уровней">
        <svg class="ico green" viewBox="0 0 18 18">
          <path d="M3 1v16M4 2h8l-2.5 3L12 8H4z" fill="currentColor"/>
        </svg>
        <span id="levelsCleared">0</span>
      </div>

      <div id="perks">
        <!-- Map perk -->
        <div id="perkMap" class="perk" title="Карта уровня (20)">
          <svg class="ico" viewBox="0 0 18 18" style="fill:#cfe3ff">
            <path d="M3 4l4-2 4 2 4-2v12l-4 2-4-2-4 2V4zM7 4v10M11 6v10" />
          </svg>
          <span class="price">20</span>
        </div>
        <!-- Jump perk (Classic) -->
        <div id="perkJump" class="perk" title="Прыжок (10, только Classic)">
          <svg class="ico" viewBox="0 0 18 18" style="fill:#cfe3ff">
            <path d="M9 3l4 4H10v8H8V7H5l4-4z"/>
          </svg>
          <span class="price">10</span>
        </div>
      </div>
      <span id="modeText"></span>
    </div>
  </div>

  <canvas id="map3d"></canvas>
  <div id="exitRing"></div>
  <div id="buyRing"></div>
  <div id="exitWarn">Нужно принести 10 алмазов, чтобы перейти на следующий уровень</div>
  <div id="toastWrap"></div>

  <!-- Мобильный UI -->
  <div id="mobileUI">
    <div id="lookPad"></div>
    <div class="stickWrap" id="stickL"><div class="stickKnob" id="stickKnob"></div></div>
    <div class="mobBtns">
      <div class="mobRow">
        <button class="mobBtn" id="btnJump">Прыжок</button>
        <button class="mobBtn" id="btnDown">Снижение</button>
      </div>
      <div class="mobRow">
        <button class="mobBtn" id="btnMap">Карта</button>
        <button class="mobBtn" id="btnSave">Сохранить</button>
        <button class="mobBtn" id="btnFS">На весь экран</button>
        <button class="mobBtn" id="btnMenu">Меню</button>
      </div>
    </div>
  </div>

<script type="module">
/* ===== v8 (HUD icons, same save format) ===== */

const diamondUI = document.getElementById('diamondCount');
const totalUI   = document.getElementById('totalDiamonds');
const levelsUI  = document.getElementById('levelsCleared');
const modeUI    = document.getElementById('modeText');
const mapCanvas = document.getElementById('map3d');
const exitRing  = document.getElementById('exitRing');
const buyRing   = document.getElementById('buyRing');
const exitWarn  = document.getElementById('exitWarn');
const toastWrap = document.getElementById('toastWrap');

const mainMenu   = document.getElementById('mainMenu');
const menuInput  = document.getElementById('menuSaveInput');
const btnContinue= document.getElementById('btnContinue');
const btnClassic = document.getElementById('btnClassic');
const btnBiomes  = document.getElementById('btnBiomes');

/* perks icons */
const perkMap  = document.getElementById('perkMap');
const perkJump = document.getElementById('perkJump');

/* mobile refs */
const mobileUI = document.getElementById('mobileUI');
const lookPad  = document.getElementById('lookPad');
const stickL   = document.getElementById('stickL');
const stickKnob= document.getElementById('stickKnob');
const btnJump  = document.getElementById('btnJump');
const btnDown  = document.getElementById('btnDown');
const btnMapBtn= document.getElementById('btnMap');
const btnSave  = document.getElementById('btnSave');
const btnFS    = document.getElementById('btnFS');
const btnMenu  = document.getElementById('btnMenu');

// Debug panel element (hidden by default)
const debugPanel = document.createElement('div');
debugPanel.id = 'debugPanel';
debugPanel.style.cssText = 'margin-top:8px; font:12px/1.2 monospace; background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,.2); border-radius:8px; padding:6px 8px; display:none; max-width:72vw; white-space:pre-wrap;';
document.getElementById('overlay').appendChild(debugPanel);

function showToast(msg, type='success', ms=2200){
  const el = document.createElement('div');
  el.className = `toast ${type}`;
  el.textContent = msg;
  toastWrap.appendChild(el);
  requestAnimationFrame(()=>el.classList.add('show'));
  setTimeout(()=>{ el.classList.remove('show'); setTimeout(()=>toastWrap.removeChild(el), 220); }, ms);
}
async function copyText(text){
  try{ await navigator.clipboard.writeText(text); return true; }
  catch{
    const ta = document.createElement('textarea');
    ta.value = text; document.body.appendChild(ta);
    ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
    return true;
  }
}

async function loadLibs(){
  return {
    THREE: await import('./vendor/three/three.module.js'),
    PLC: (await import('./vendor/three/PointerLockControls.js')).PointerLockControls
  };
}

(async ()=>{
  let THREE, PointerLockControls;
  try{
    const libs = await loadLibs();
    THREE = libs.THREE; PointerLockControls = libs.PLC;
  }catch(e){
    console.error(e);
    showToast('Не удалось загрузить three.js', 'err', 3000);
    return;
  }

  const isMobile = /Android|iPhone|iPad|iPod|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent)
                    || (('ontouchstart' in window) && window.matchMedia('(max-width: 900px)').matches);

  const cellSize = 5, mazeSize = 15, toWin = 10;
  const playerRadius = cellSize*0.35, WALL_HEIGHT = cellSize;
  const DIAMOND_COUNT = 15, SUPER_CHANCE = 0.12;

  function LCG(seedInit=1){
    let s = (seedInit>>>0)||1; const a = 1664525>>>0, c = 1013904223>>>0;
    return { set(v){ s=(v>>>0)||1; }, next(){ s=(Math.imul(a,s)+c)>>>0; return s; },
      float(){ return this.next()/4294967296; }, int(n){ return Math.floor(this.next()/4294967296*n); }, raw(){return s>>>0;} };
  }
  let mazeSeed = 0x1234, diamondsSeed = 0xBEEF, biomeSeed = 0xA55A;
  const rngMaze = LCG(mazeSeed), rngDiam = LCG(diamondsSeed), rngBiome = LCG(biomeSeed);
  const randIntM = n => rngMaze.int(n);
  function reseedMaze(s){ mazeSeed = (s & 0x07FF)>>>0; rngMaze.set(mazeSeed); }
  function reseedDiam(s){ diamondsSeed = (s & 0x07FF)>>>0; rngDiam.set(diamondsSeed); }
  function reseedBiome(s){ biomeSeed = (s & 0x07FF)>>>0; rngBiome.set(biomeSeed); }

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.add(new THREE.Mesh(new THREE.SphereGeometry(1500, 32, 32),
    new THREE.MeshBasicMaterial({ color:0x87CEEB, side:THREE.BackSide })));

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.rotation.order = 'YXZ';
  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
  // Quality preset and pixel ratio cap; adjusted later
  let quality = 'high';
  let pixelRatioCap = 2;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, pixelRatioCap));
  if (THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  let mapRenderer; // will be created later for 3D map
  const controls = new PointerLockControls(camera, renderer.domElement);
  renderer.domElement.addEventListener('click', ()=>{
    if (mainMenu.style.display==='none' && !isMobile) controls.lock();
  });
  scene.add(controls.getObject());

  scene.add(new THREE.HemisphereLight(0xffffff, 0x40405a, 0.9));
  const sun = new THREE.DirectionalLight(0xffffff, 0.7); sun.position.set(20,40,10); scene.add(sun);

  const texLoader = new THREE.TextureLoader();
  const grass = texLoader.load('assets/textures/grasslight-big.jpg');
  grass.wrapS = grass.wrapT = THREE.RepeatWrapping; grass.anisotropy = 8; if (THREE.SRGBColorSpace) grass.colorSpace = THREE.SRGBColorSpace;
  const brick = texLoader.load('assets/textures/brick_diffuse.jpg');
  brick.wrapS = brick.wrapT = THREE.RepeatWrapping; brick.anisotropy = 8; if (THREE.SRGBColorSpace) brick.colorSpace = THREE.SRGBColorSpace;
  // Quality apply function (after textures are available)
  function applyQuality(level){
    quality = level || quality;
    const isMobile = /Android|iPhone|iPad|iPod|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent)
                      || (('ontouchstart' in window) && window.matchMedia('(max-width: 900px)').matches);
    const baseCap = isMobile ? 1.5 : 2;
    const cap = (quality==='low') ? 1.0 : (quality==='med') ? Math.min(baseCap, 1.5) : baseCap;
    pixelRatioCap = cap;
    const ratio = Math.min(window.devicePixelRatio || 1, pixelRatioCap);
    renderer.setPixelRatio(ratio);
    if (typeof mapRenderer !== 'undefined' && mapRenderer) {
      mapRenderer.setPixelRatio(ratio);
    }
    const maxAniso = renderer.capabilities.getMaxAnisotropy?.() || 8;
    const aniso = (quality==='low') ? Math.min(2, maxAniso) : (quality==='med') ? Math.min(4, maxAniso) : Math.min(8, maxAniso);
    if (grass && 'anisotropy' in grass) grass.anisotropy = aniso;
    if (brick && 'anisotropy' in brick) brick.anisotropy = aniso;
  }
  applyQuality(quality);

  const floorMat = new THREE.MeshLambertMaterial({ map: grass });
  const wallMat  = new THREE.MeshLambertMaterial({ map: brick });
  const diamondMat = new THREE.MeshLambertMaterial({ color:0x00ffff, emissive:0x003344, emissiveIntensity:0.7 });
  const superDiamondMat = new THREE.MeshLambertMaterial({ color:0x9b59b6, emissive:0x2e0854, emissiveIntensity:0.9 });
  const exitMat = new THREE.MeshLambertMaterial({ color:0x22cc55 });

  const wallGeo = new THREE.BoxGeometry(cellSize, WALL_HEIGHT, cellSize);
  const diamondGeo = new THREE.OctahedronGeometry(1.2, 0);
  const superDiamondGeo = new THREE.IcosahedronGeometry(1.5, 0);

  function generateMaze(w,h){
    if (w%2===0) w++; if (h%2===0) h++;
    const g = Array.from({length:h}, ()=>Array(w).fill(1));
    function carve(x,y){
      g[y][x]=0;
      const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
      for (let i=dirs.length-1;i>0;i--){ const j=randIntM(i+1); [dirs[i],dirs[j]]=[dirs[j],dirs[i]]; }
      for (const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if (nx>0 && ny>0 && nx<w-1 && ny<h-1 && g[ny][nx]===1){
          g[y+dy/2][x+dx/2]=0; carve(nx,ny);
        }
      }
    }
    carve(1,1);
    g[h-2][w-2]=0;
    return g;
  }

  let maze=[], mazeGroup=null, exitMesh=null, exitCell={x:0,y:0};
  let biomeGroup=null, obstacles=null;
  const _tmpObj = new THREE.Object3D();
  function buildMazeMesh(){
    if (mazeGroup) scene.remove(mazeGroup);
    mazeGroup = new THREE.Group(); scene.add(mazeGroup);

    const W = maze[0].length, H = maze.length;

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(W*cellSize, H*cellSize), floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.set((W*cellSize)/2, 0, (H*cellSize)/2);
    floor.material.map.repeat.set(W, H);
    mazeGroup.add(floor);

    let wallCount=0;
    for (let y=0;y<H;y++)
      for (let x=0;x<W;x++) if (maze[y][x]===1) wallCount++;
    if (wallCount>0){
      const inst = new THREE.InstancedMesh(wallGeo, wallMat, wallCount);
      let i=0;
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if (maze[y][x]!==1) continue;
          _tmpObj.position.set((x+0.5)*cellSize, WALL_HEIGHT/2, (y+0.5)*cellSize);
          _tmpObj.rotation.set(0,0,0);
          _tmpObj.updateMatrix();
          inst.setMatrixAt(i++, _tmpObj.matrix);
        }
      }
      inst.instanceMatrix.needsUpdate = true;
      mazeGroup.add(inst);
    }

    const ex=W-2, ey=H-2;
    exitCell = {x:ex, y:ey};
    exitMesh = new THREE.Mesh(new THREE.CylinderGeometry(1.9,1.9,0.35,24), exitMat);
    exitMesh.position.set((ex+0.5)*cellSize, 0.175, (ey+0.5)*cellSize);
    mazeGroup.add(exitMesh);
  }

  function generateObstaclesIfNeeded(){
    const W = maze[0].length, H = maze.length;
    obstacles = Array.from({length:H}, ()=>Array(W).fill(0));
    if (gameMode!=='biomes') return;

    let attempt=0;
    while (attempt<5){
      for (let y=0;y<H;y++) obstacles[y].fill(0);
      const pTree=0.08, pWater=0.06, pStairs=0.05;
      for (let y=1;y<H-1;y++){
        for (let x=1;x<W-1;x++){
          if (maze[y][x]!==0) continue;
          if ((x===1&&y===1) || (x===exitCell.x && y===exitCell.y)) continue;
          const r = rngBiome.float();
          if (r < pTree) { obstacles[y][x]=1; }
          else if (r < pTree+pWater) { obstacles[y][x]=2; }
          else if (r < pTree+pWater+pStairs) { obstacles[y][x]=3; }
        }
      }
      // Place up to 2 jump pads (type 4): stepping grants a powerful jump
      let candidates = [];
      for (let y=1;y<H-1;y++){
        for (let x=1;x<W-1;x++){
          if (maze[y][x]!==0) continue;
          if (obstacles[y][x]!==0) continue;
          if ((x===1&&y===1) || (x===exitCell.x && y===exitCell.y)) continue;
          candidates.push({x,y});
        }
      }
      // Shuffle using rngBiome
      for (let i=candidates.length-1;i>0;i--){ const j=rngBiome.int(i+1); const t=candidates[i]; candidates[i]=candidates[j]; candidates[j]=t; }
      const padCount = Math.min(2, candidates.length);
      for (let i=0;i<padCount;i++){
        const c = candidates[i]; obstacles[c.y][c.x] = 4;
      }
      if (isReachable()) break;
      attempt++; rngBiome.set((rngBiome.raw() ^ 0x9E3779B9)>>>0);
    }
  }
  function isReachable(){
    const W = maze[0].length, H = maze.length;
    const q=[[1,1]]; let qi=0; const vis=new Set(['1,1']);
    while (qi<q.length){
      const [x,y]=q[qi++];
      if (x===exitCell.x && y===exitCell.y) return true;
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if (nx<0||ny<0||nx>=W||ny>=H) continue;
        if (maze[ny][nx]!==0) continue;
        const ot = obstacles[ny][nx]||0;
        if (ot!==0 && ot!==4) continue; // pads are passable
        const k=nx+','+ny;
        if (!vis.has(k)){ vis.add(k); q.push([nx,ny]); }
      }
    }
    return false;
  }
  function buildBiomeMeshes(){
    if (biomeGroup) scene.remove(biomeGroup);
    biomeGroup = new THREE.Group(); scene.add(biomeGroup);
    if (gameMode!=='biomes') return;

    const trunkMat = new THREE.MeshLambertMaterial({ color:0x8b5a2b });
    const leafMat  = new THREE.MeshLambertMaterial({ color:0x2ecc71 });
    const waterMat = new THREE.MeshPhongMaterial({ color:0x2980b9, transparent:true, opacity:0.8, shininess:50 });
    const stairMat = new THREE.MeshLambertMaterial({ color:0xc0c0c0 });
    const padMat   = new THREE.MeshLambertMaterial({ color:0x00d0ff, emissive:0x003355, emissiveIntensity:0.8 });

    const W = maze[0].length, H = maze.length;
    for (let y=0;y<H;y++) for (let x=0;x<W;x++){
      const t = obstacles[y][x]; if (!t) continue;
      const cx=(x+0.5)*cellSize, cz=(y+0.5)*cellSize;
      if (t===1){
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.6,2.2,8), trunkMat);
        trunk.position.set(cx, 1.1, cz); biomeGroup.add(trunk);
        const crown = new THREE.Mesh(new THREE.ConeGeometry(1.8, 3.2, 12), leafMat);
        crown.position.set(cx, 3.1, cz); biomeGroup.add(crown);
      }else if (t===2){
        const pond = new THREE.Mesh(new THREE.BoxGeometry(cellSize*0.9, 0.2, cellSize*0.9), waterMat);
        pond.position.set(cx, 0.1, cz); biomeGroup.add(pond);
      }else if (t===3){
        const stair = new THREE.Mesh(new THREE.BoxGeometry(cellSize*0.9, 1.0, cellSize*0.9), stairMat);
        stair.position.set(cx, 0.5, cz); stair.rotation.y = (x+y)%2 ? Math.PI/4 : -Math.PI/4;
        biomeGroup.add(stair);
      }else if (t===4){
        const pad = new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.22,20), padMat);
        pad.position.set(cx, 0.11, cz); biomeGroup.add(pad);
        const ring = new THREE.Mesh(new THREE.TorusGeometry(1.6, 0.08, 8, 32), padMat);
        ring.position.set(cx, 0.3, cz); ring.rotation.x = Math.PI/2; biomeGroup.add(ring);
      }
    }
  }

  let diamondsRef=[], diamonds=[];
  function generateDiamondsRef(){
    const W = maze[0].length, H = maze.length;
    const used = new Set(); diamondsRef=[];
    let tries=0;
    while (diamondsRef.length < DIAMOND_COUNT && tries < 5000){
      tries++;
      const px = rngDiam.int(W), py = rngDiam.int(H);
      const key = px+'_'+py;
      if (maze[py]?.[px]!==0) continue;
      if (obstacles && obstacles[py][px]!==0) continue;
      if ((px===1&&py===1) || (px===exitCell.x&&py===exitCell.y)) continue;
      if (used.has(key)) continue;
      used.add(key);
      const isSuper = rngDiam.float() < SUPER_CHANCE;
      diamondsRef.push({x:px, y:py, type: isSuper?'S':'N'});
    }
    let totalValue = diamondsRef.reduce((s,d)=>s+(d.type==='S'?20:1),0), i=0;
    while (totalValue < toWin + 5 && i<diamondsRef.length){
      if (diamondsRef[i].type==='N'){ diamondsRef[i].type='S'; totalValue+=19; }
      i++;
    }
  }
  function spawnDiamondsFromRef(maskBig){
    diamonds.forEach(d=>scene.remove(d)); diamonds=[];
    for (let i=0;i<diamondsRef.length;i++){
      const bit = (maskBig >> BigInt(i)) & 1n; if (bit===1n) continue;
      const ref = diamondsRef[i];
      const geo = (ref.type==='S') ? superDiamondGeo : diamondGeo;
      const mat = (ref.type==='S') ? superDiamondMat : diamondMat;
      const d = new THREE.Mesh(geo, mat);
      d.userData.idx = i; d.userData.type = ref.type;
      d.position.set((ref.x+0.5)*cellSize, 1.6, (ref.y+0.5)*cellSize);
      scene.add(d); diamonds.push(d);
    }
  }

  /* 3D-карта */
  mapRenderer = new THREE.WebGLRenderer({ canvas: mapCanvas, alpha:true, antialias:true });
  mapRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, pixelRatioCap));
  mapRenderer.setClearColor(0x000000, 0);
  const mapScene = new THREE.Scene();
  const mapCam = new THREE.PerspectiveCamera(60, 1, 0.1, 5000);
  const mapLight = new THREE.DirectionalLight(0xffffff, 0.9); mapLight.position.set(100,200,100);
  mapScene.add(new THREE.AmbientLight(0xffffff, 0.6)); mapScene.add(mapLight);

  let mapMazeGroup=null, mapDiamonds=[], mapPlayer=null, mapExit=null;
  let lastMapMask = null;
  function buildMapScene(){
    if (mapMazeGroup) mapScene.remove(mapMazeGroup);
    mapMazeGroup = new THREE.Group(); mapScene.add(mapMazeGroup);
    mapDiamonds.forEach(m=>mapScene.remove(m)); mapDiamonds=[]; if (mapExit) mapScene.remove(mapExit);

    const W = maze[0].length, H = maze.length;
    const gFloor = new THREE.Mesh(new THREE.PlaneGeometry(W*cellSize, H*cellSize),
      new THREE.MeshLambertMaterial({ color:0x335533 }));
    gFloor.rotation.x = -Math.PI/2; gFloor.position.set((W*cellSize)/2, 0, (H*cellSize)/2);
    mapMazeGroup.add(gFloor);

    const wMat = new THREE.MeshBasicMaterial({ color:0xffffff, wireframe:true });
    let wCount=0;
    for (let y=0;y<H;y++) for (let x=0;x<W;x++) if (maze[y][x]===1) wCount++;
    if (wCount>0){
      const instW = new THREE.InstancedMesh(wallGeo, wMat, wCount);
      let wi=0;
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if (maze[y][x]!==1) continue;
          _tmpObj.position.set((x+0.5)*cellSize, WALL_HEIGHT/2, (y+0.5)*cellSize);
          _tmpObj.rotation.set(0,0,0);
          _tmpObj.updateMatrix();
          instW.setMatrixAt(wi++, _tmpObj.matrix);
        }
      }
      instW.instanceMatrix.needsUpdate = true;
      mapMazeGroup.add(instW);
    }

    // build diamonds once per current mask
    lastMapMask = buildMaskBigInt();
    for (const d of diamonds){
      const m = new THREE.Mesh(
        d.userData.type==='S' ? superDiamondGeo : diamondGeo,
        new THREE.MeshBasicMaterial({ color: d.userData.type==='S' ? 0x9b59b6 : 0x00ffff })
      );
      m.position.copy(d.position); mapScene.add(m); mapDiamonds.push(m);
    }
    mapExit = new THREE.Mesh(new THREE.CylinderGeometry(2,2,0.6,20), new THREE.MeshBasicMaterial({color:0x22cc55}));
    mapExit.position.copy(exitMesh.position); mapScene.add(mapExit);

    if (!mapPlayer){
      mapPlayer = new THREE.Mesh(new THREE.ConeGeometry(2.2, 4, 16), new THREE.MeshBasicMaterial({ color:0xff3333 }));
      mapScene.add(mapPlayer);
    }

    const centerX = (W*cellSize)/2, centerZ = (H*cellSize)/2;
    const maxSide = Math.max(W*cellSize, H*cellSize);
    mapCam.position.set(centerX, maxSide*0.9, centerZ);
    mapCam.lookAt(centerX, 0, centerZ);

    const w = mapCanvas.clientWidth || 800, h = mapCanvas.clientHeight || 600;
    mapRenderer.setSize(w, h, false); mapCam.aspect = w/h; mapCam.updateProjectionMatrix();
  }
  function updateMapScene(){
    if (mapCanvas.style.display==='none') return;
    if (mapPlayer){
      const p = controls.getObject().position;
      mapPlayer.position.set(p.x, 3, p.z);
      mapPlayer.rotation.set(0, camera.rotation.y, 0);
    }
    const curMask = buildMaskBigInt();
    if (lastMapMask===null || curMask!==lastMapMask){
      for (const m of mapDiamonds) mapScene.remove(m);
      mapDiamonds = [];
      for (const d of diamonds){
        const m = new THREE.Mesh(
          d.userData.type==='S' ? superDiamondGeo : diamondGeo,
          new THREE.MeshBasicMaterial({ color: d.userData.type==='S' ? 0x9b59b6 : 0x00ffff })
        );
        m.position.copy(d.position); mapScene.add(m); mapDiamonds.push(m);
      }
      lastMapMask = curMask;
    }
    mapRenderer.render(mapScene, mapCam);
  }

  /* Состояние */
  let diamondCount=0, totalDiamonds=0, levelsCleared=0, mapUnlocked=false;
  let gameMode = 'classic';
  let jumpUnlockedClassic = false;

  function updateHUD(){
    // counts are updated via textContent, here update perk states/visibility
    perkMap.classList.toggle('on', mapUnlocked);
    perkMap.classList.toggle('can', !mapUnlocked && totalDiamonds>=20);
    // jump icon only in Classic
    if (gameMode==='classic'){
      perkJump.style.display='flex';
      perkJump.classList.toggle('on', jumpUnlockedClassic);
      perkJump.classList.toggle('can', !jumpUnlockedClassic && totalDiamonds>=10);
    }else{
      perkJump.style.display='none';
    }
  }

  function toggleMap(){
    if (!mapUnlocked){
      if (totalDiamonds >= 20){
        totalDiamonds -= 20; totalUI.textContent = totalDiamonds;
        mapUnlocked = true; updateHUD();
        mapCanvas.style.display='block'; buildMapScene(); return;
      }else{ showToast('Нужно 20 алмазов для карты', 'warn'); return; }
    }
    if (mapCanvas.style.display==='none'){ mapCanvas.style.display='block'; buildMapScene(); }
    else mapCanvas.style.display='none';
  }

  function blockHeightAt(gx,gz){
    if ((maze[gz]?.[gx])===1) return WALL_HEIGHT;
    if (obstacles){
      const t = obstacles[gz]?.[gx] || 0;
      if (t===1) return 3.6;
      if (t===2) return 0.25;
      if (t===3) return 1.0;
      if (t===4) return 0.0; // jump pad is flat
    }
    return 0;
  }
  function groundHeightAtWorld(x,z){
    return blockHeightAt(Math.floor(x/cellSize), Math.floor(z/cellSize));
  }
  function isBlockedAt(gx,gz,posY){
    const h = blockHeightAt(gx,gz);
    if (h<=0) return false;
    return posY <= h + playerRadius*0.6;
  }

  /* Сейвы (v8) */
  function base36FromBigInt(x){ return x.toString(36).toUpperCase(); }
  function bigIntFromBase36(str){ let x=0n; for (const ch of str.trim().toLowerCase()){
    const c=ch.charCodeAt(0); let v; if (c>=48&&c<=57) v=BigInt(c-48); else if (c>=97&&c<=122) v=BigInt(c-87); else continue; x=x*36n+v; } return x; }
  function clamp(v,min,max){ return v<min?min:v>max?max:v; }
  function getGridPos(){
    const p=controls.getObject().position;
    const gx = Math.max(0, Math.min(15, Math.floor(p.x/cellSize)));
    const gz = Math.max(0, Math.min(15, Math.floor(p.z/cellSize)));
    const fx = Math.max(0, Math.min(15, Math.round(((p.x/cellSize)-gx)*15)));
    const fz = Math.max(0, Math.min(15, Math.round(((p.z/cellSize)-gz)*15)));
    return { gx, gz, fx, fz };
  }
  function buildMaskBigInt(){
    let mask=0n; const aliveIdx=new Set(diamonds.map(d=>d.userData.idx));
    for (let i=0;i<DIAMOND_COUNT;i++) if (!aliveIdx.has(i)) mask|=(1n<<BigInt(i));
    return mask;
  }
  function encodeSave(){
    const v = 8n;
    const {gx,gz,fx,fz} = getGridPos();
    const yawF   = ((camera.rotation.y % (Math.PI*2)) + Math.PI*2)%(Math.PI*2);
    const yaw5   = BigInt(clamp(Math.round(yawF/(Math.PI*2)*31),0,31));
    const pitchL = Math.PI*0.49;
    const pitchF = clamp(camera.rotation.x, -pitchL, pitchL);
    const pitch5 = BigInt(clamp(Math.round((pitchF + pitchL)/(2*pitchL) * 31),0,31));
    const posY   = clamp(controls.getObject().position.y, 0, 31);
    const y5     = BigInt(Math.round(posY));
    const fly    = isFlying ? 1n : 0n;

    const total = BigInt(clamp(totalDiamonds,0,511));
    const levels= BigInt(clamp(levelsCleared,0,31));
    const map   = mapUnlocked ? 1n : 0n;
    const jump  = (gameMode==='classic' && jumpUnlockedClassic) ? 1n : 0n;
    const modeBit = gameMode==='biomes' ? 1n : 0n;
    const mask  = buildMaskBigInt();

    let code=0n;
    code=(code<<4n)|v;
    code=(code<<11n)|BigInt(mazeSeed & 0x07FF);
    code=(code<<11n)|BigInt(diamondsSeed & 0x07FF);
    code=(code<<11n)|BigInt(biomeSeed & 0x07FF);
    code=(code<<1n)|modeBit;
    code=(code<<4n)|BigInt(gx & 0xF);
    code=(code<<4n)|BigInt(gz & 0xF);
    code=(code<<4n)|BigInt(fx & 0xF);
    code=(code<<4n)|BigInt(fz & 0xF);
    code=(code<<5n)|y5;
    code=(code<<1n)|fly;
    code=(code<<5n)|yaw5;
    code=(code<<5n)|pitch5;
    code=(code<<9n)|total;
    code=(code<<5n)|levels;
    code=(code<<1n)|map;
    code=(code<<1n)|jump;
    code=(code<<15n)|mask;

    return base36FromBigInt(code);
  }
  function decodeSave(str){
    const x0 = bigIntFromBase36(str); let x=x0;
    const mask   = x & ((1n<<15n)-1n);  x >>= 15n;
    const jump   = x & 1n;              x >>= 1n;
    const map    = x & 1n;              x >>= 1n;
    const levels = x & ((1n<<5n)-1n);   x >>= 5n;
    const total  = x & ((1n<<9n)-1n);   x >>= 9n;
    const pitch5 = x & ((1n<<5n)-1n);   x >>= 5n;
    const yaw5   = x & ((1n<<5n)-1n);   x >>= 5n;
    const fly    = x & 1n;              x >>= 1n;
    const y5     = x & ((1n<<5n)-1n);   x >>= 5n;
    const fz     = x & ((1n<<4n)-1n);   x >>= 4n;
    const fx     = x & ((1n<<4n)-1n);   x >>= 4n;
    const gz     = x & ((1n<<4n)-1n);   x >>= 4n;
    const gx     = x & ((1n<<4n)-1n);   x >>= 4n;
    const mode   = x & 1n;              x >>= 1n;
    const bseed  = x & ((1n<<11n)-1n);  x >>= 11n;
    const dseed  = x & ((1n<<11n)-1n);  x >>= 11n;
    const mseed  = x & ((1n<<11n)-1n);  x >>= 11n;
    const v      = x & ((1n<<4n)-1n);
    if (Number(v)!==8) throw new Error('Неподдерживаемая версия сейва (v8)');
    return {
      mseed:Number(mseed), dseed:Number(dseed), bseed:Number(bseed),
      mode:Boolean(mode), gx:Number(gx), gz:Number(gz), fx:Number(fx), fz:Number(fz),
      y:Number(y5), fly:(fly===1n), yaw:Number(yaw5), pitch:Number(pitch5),
      total:Number(total), levels:Number(levels), map: (map===1n), jump:(jump===1n), mask
    };
  }
  function isValidSave(str){
    try{
      const d = decodeSave(str);
      if (d.gx<0||d.gx>15||d.gz<0||d.gz>15) return false;
      if (d.fx<0||d.fx>15||d.fz<0||d.fz>15) return false;
      if (d.y<0||d.y>31) return false;
      if (d.yaw<0||d.yaw>31||d.pitch<0||d.pitch>31) return false;
      if (d.total<0||d.total>511) return false;
      if (d.levels<0||d.levels>31) return false;
      return true;
    }catch{ return false; }
  }

  /* Управление / геймплей */
  let canExit=false, exitStartT=0, onExitCellLast=false;
  const keys = Object.create(null);

  // Debug state and FPS counters
  let debugOn = false;
  let fps = 0, _fpsAccum = 0, _fpsFrames = 0;

  let velY = 0;
  const GRAV = -25, JUMP_V = 8, JUMP_V_PAD = 16, FLY_V = 10;
  let onGround = true, isFlying = false, lastSpaceTime = 0;
  let buyHold=false, buyStart=0;
  let deathCooldownUntil = 0;

  function isOnJumpPad(){
    if (gameMode!=='biomes' || !obstacles) return false;
    const c = playerCell();
    return (obstacles[c.y]?.[c.x]===4);
  }

  window.addEventListener('keydown', e=>{
    keys[e.code]=true;

    if (e.code==='KeyM') toggleMap();
    if (e.code==='Digit0'){
      debugOn = !debugOn;
      debugPanel.style.display = debugOn ? 'block' : 'none';
      showToast(debugOn ? 'Debug ON (0)' : 'Debug OFF (0)', debugOn ? 'success' : 'warn');
    }
    if (e.code==='KeyQ'){
      const order=['low','med','high'];
      const idx = order.indexOf(quality);
      applyQuality(order[(idx+1)%order.length]);
      showToast(`Качество: ${quality.toUpperCase()}`, 'success');
    }
    if (e.code==='Digit1'){
      const code=encodeSave();
      copyText(code).then(()=>showToast(`Сохранение скопировано: ${code}`, 'success', 2600));
      for (const k in keys) keys[k]=false;
    }
    if (e.code==='Digit2'){
      const code=prompt('Вставьте код сохранения (v8):');
      if (code) loadFromCode(code.trim());
      for (const k in keys) keys[k]=false;
    }
    if (e.code==='Digit3'){ totalDiamonds+=100; totalUI.textContent=totalDiamonds; updateHUD(); showToast('+100 алмазов', 'success'); }
    if (e.code==='Digit4'){ goToMainMenu(); }

    if (e.code==='Space'){
      if (e.repeat) return;
      const now=performance.now();
      const classicLocked = (gameMode==='classic' && !jumpUnlockedClassic);

      if (classicLocked){
        if (!buyHold){ buyHold = true; buyStart = now; buyRing.style.display='block'; }
        e.preventDefault(); return;
      }

      if (now - lastSpaceTime < 300){
        isFlying = !isFlying;
        if (isFlying){ velY=0; onGround=false; }
      }else{
        if (!isFlying && onGround){ velY = isOnJumpPad() ? JUMP_V_PAD : JUMP_V; onGround=false; }
      }
      lastSpaceTime = now;
    }
  });

  window.addEventListener('keyup', e=>{
    keys[e.code]=false;
    if (e.code==='Space' && buyHold){ buyHold=false; buyRing.style.display='none'; }
  });

  const tileX = x => Math.floor(x / cellSize);
  const tileZ = z => Math.floor(z / cellSize);

  function moveWithCollisions(dx, dz){
    const pos = controls.getObject().position;
    const half = cellSize/2;

    let nx = pos.x + dx;
    let gx = tileX(nx);
    let gz = tileZ(pos.z);
    let cx = (gx + 0.5) * cellSize;
    let offX = nx - cx;

    if (offX < -half + playerRadius) { if (isBlockedAt(gx - 1, gz, pos.y)) nx = cx - half + playerRadius; }
    if (offX >  half - playerRadius) { if (isBlockedAt(gx + 1, gz, pos.y)) nx = cx + half - playerRadius; }
    pos.x = nx;

    let nz = pos.z + dz;
    gx = tileX(pos.x);
    gz = tileZ(nz);
    let cz = (gz + 0.5) * cellSize;
    let offZ = nz - cz;

    if (offZ < -half + playerRadius) { if (isBlockedAt(gx, gz - 1, pos.y)) nz = cz - half + playerRadius; }
    if (offZ >  half - playerRadius) { if (isBlockedAt(gx, gz + 1, pos.y)) nz = cz + half - playerRadius; }
    pos.z = nz;
  }

  const up = new THREE.Vector3(0,1,0), forward = new THREE.Vector3(), right = new THREE.Vector3();

  function playerCell(){ const p = controls.getObject().position; return { x: Math.floor(p.x/cellSize), y: Math.floor(p.z/cellSize) }; }

  function setView(yaw, pitch){
    camera.rotation.order = 'YXZ';
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;
    camera.rotation.z = 0;
  }

  function onVictory(){
    mapCanvas.style.display='none';
    levelsCleared++; levelsUI.textContent = levelsCleared;
    if (gameMode==='classic') jumpUnlockedClassic=false;
    updateHUD();
    showToast(`Победа! Принесено: ${diamondCount}. Уровни: ${levelsCleared}`, 'success', 2600);
    resetRun();
  }

  function killAndRespawn(){
    const now = performance.now();
    deathCooldownUntil = now + 1000;
    diamondCount = 0; diamondUI.textContent = diamondCount;
    isFlying = false; velY=0; onGround=true;
    controls.getObject().position.set((1+0.5)*cellSize, 2, (1+0.5)*cellSize);
    setView(0,0);
    mapCanvas.style.display='none';
    showToast('Вы упали за край. Возврат к началу.', 'warn', 2400);
  }

  function updateBuyRing(){
    if (!buyHold){ buyRing.style.display='none'; return; }
    if (gameMode!=='classic' || jumpUnlockedClassic){ buyRing.style.display='none'; buyHold=false; return; }
    const need=10;
    if (totalDiamonds < need){
      buyRing.style.display='none'; buyHold=false;
      showToast('Нужно 10 алмазов для прыжков', 'warn'); return;
    }
    const prog = Math.min(1, (performance.now()-buyStart)/5000);
    const deg = Math.floor(prog*360);
    buyRing.style.display='block';
    buyRing.style.background = `conic-gradient(#44ff77 ${deg}deg, rgba(255,255,255,0.12) ${deg}deg 360deg)`;
    if (prog>=1){
      totalDiamonds -= need; totalUI.textContent=totalDiamonds;
      jumpUnlockedClassic = true;
      buyRing.style.display='none'; buyHold=false;
      updateHUD();
      showToast('Прыжки активированы на этот уровень', 'success');
    }
  }

  const clock = new THREE.Clock();

  /* Мобильные оси/взгляд — Minecraft-подобно */
  let mobAx=0, mobAz=0;               // -1..1
  let lookId=null, lookLastX=0, lookLastY=0;
  let stickId=null, stickCX=0, stickCY=0, stickR=70;

  function setMobileUIVisible(show){ mobileUI.style.display = show ? 'block' : 'none'; }

  const stickRect = ()=>stickL.getBoundingClientRect();
  stickL.addEventListener('touchstart', (e)=>{
    for (const t of e.changedTouches){
      if (stickId===null){
        stickId = t.identifier;
        const b=stickRect(); stickCX=b.left+b.width/2; stickCY=b.top+b.height/2;
        stickKnob.style.left='50%'; stickKnob.style.top='50%';
        e.preventDefault(); break;
      }
    }
  }, {passive:false});
  stickL.addEventListener('touchmove', (e)=>{
    for (const t of e.changedTouches){
      if (t.identifier!==stickId) continue;
      const dx=t.clientX-stickCX, dy=t.clientY-stickCY;
      const len=Math.hypot(dx,dy); const max=stickR-20;
      const k = len>max ? max/len : 1;
      const nx=dx*k, ny=dy*k;
      stickKnob.style.left = `calc(50% + ${nx}px)`;
      stickKnob.style.top  = `calc(50% + ${ny}px)`;
      mobAx =  nx/max;
      mobAz = -ny/max;
      e.preventDefault();
    }
  }, {passive:false});
  function stickRelease(){ stickId=null; mobAx=0; mobAz=0; stickKnob.style.left='50%'; stickKnob.style.top='50%'; }
  stickL.addEventListener('touchend',   (e)=>{ for (const t of e.changedTouches){ if (t.identifier===stickId){ stickRelease(); break; } } }, {passive:false});
  stickL.addEventListener('touchcancel',(e)=>{ for (const t of e.changedTouches){ if (t.identifier===stickId){ stickRelease(); break; } } }, {passive:false});

  function isOnControls(el){ return el.closest('#stickL') || el.closest('.mobBtns'); }
  lookPad.addEventListener('touchstart',(e)=>{
    for (const t of e.changedTouches){
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (isOnControls(el)) continue;
      if (lookId===null){ lookId=t.identifier; lookLastX=t.clientX; lookLastY=t.clientY; e.preventDefault(); break; }
    }
  }, {passive:false});
  lookPad.addEventListener('touchmove',(e)=>{
    for (const t of e.changedTouches){
      if (t.identifier!==lookId) continue;
      const dx=t.clientX-lookLastX, dy=t.clientY-lookLastY;
      lookLastX=t.clientX; lookLastY=t.clientY;
      const sens = 0.0034;
      let yaw = camera.rotation.y - dx*sens;
      let pitch = camera.rotation.x - dy*sens;
      const limit = Math.PI*0.49;
      if (pitch < -limit) pitch = -limit;
      if (pitch >  limit) pitch =  limit;
      setView(yaw, pitch);
      e.preventDefault(); break;
    }
  }, {passive:false});
  function lookRelease(){ lookId=null; }
  lookPad.addEventListener('touchend',   (e)=>{ for (const t of e.changedTouches){ if (t.identifier===lookId){ lookRelease(); break; } } }, {passive:false});
  lookPad.addEventListener('touchcancel',(e)=>{ for (const t of e.changedTouches){ if (t.identifier===lookId){ lookRelease(); break; } } }, {passive:false});

  // Кнопки
  let tapTime=0;
  const mobClassicLocked=()=> (gameMode==='classic' && !jumpUnlockedClassic);
  btnJump.addEventListener('touchstart',(e)=>{
    e.preventDefault();
    if (mobClassicLocked()){
      if (!buyHold){ buyHold=true; buyStart=performance.now(); buyRing.style.display='block'; }
      return;
    }
    const now=performance.now();
    if (now - tapTime < 300){
      isFlying = !isFlying; if (isFlying){ velY=0; onGround=false; }
    }else{
      if (!isFlying && onGround){ velY = isOnJumpPad() ? JUMP_V_PAD : JUMP_V; onGround=false; }
    }
    tapTime=now; keys['Space']=true;
  }, {passive:false});
  btnJump.addEventListener('touchend',()=>{ keys['Space']=false; if (buyHold){ buyHold=false; buyRing.style.display='none'; } });

  btnDown.addEventListener('touchstart',(e)=>{ e.preventDefault(); keys['ShiftLeft']=true; }, {passive:false});
  btnDown.addEventListener('touchend',  ()=>{ keys['ShiftLeft']=false; });

  btnMapBtn.addEventListener('touchstart',(e)=>{ e.preventDefault(); toggleMap(); }, {passive:false});
  btnSave.addEventListener('touchstart',async (e)=>{
    e.preventDefault(); const code=encodeSave();
    menuInput.value = code; await copyText(code); showToast(`Сохранение скопировано: ${code}`,'success',2600);
  }, {passive:false});
  btnMenu.addEventListener('touchstart',(e)=>{ e.preventDefault(); goToMainMenu(); }, {passive:false});

  // Полноэкранный режим
  async function toggleFullscreen(){
    try{
      if (!document.fullscreenElement){
        const el=document.documentElement;
        await (el.requestFullscreen?.() || el.webkitRequestFullscreen?.call(el));
      }else{
        await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
      }
    }catch(err){ console.warn(err); showToast('Не удалось переключить полноэкранный режим', 'err'); }
  }
  btnFS.addEventListener('touchstart',(e)=>{ e.preventDefault(); toggleFullscreen(); }, {passive:false});

  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.033, clock.getDelta());

    // FPS accumulation
    _fpsFrames++; _fpsAccum += dt;
    if (_fpsAccum >= 0.5){ fps = Math.round(_fpsFrames / _fpsAccum); _fpsFrames = 0; _fpsAccum = 0; }

    let ax=0, az=0;
    if (keys['KeyW']) az += 1;
    if (keys['KeyS']) az -= 1;
    if (keys['KeyA']) ax -= 1;
    if (keys['KeyD']) ax += 1;
    ax += mobAx; az += mobAz;

    if (ax||az){
      camera.getWorldDirection(forward);
      forward.y=0; forward.normalize();
      right.copy(forward).cross(up).normalize();

      const len = Math.hypot(ax,az) || 1;
      const speed = 9 * dt / len;
      const dx = (right.x*ax + forward.x*az) * speed;
      const dz = (right.z*ax + forward.z*az) * speed;
      moveWithCollisions(dx, dz);
    }

    const pos = controls.getObject().position;

    updateBuyRing();

    const classicLocked = (gameMode==='classic' && !jumpUnlockedClassic);
    const canFlyNow = !classicLocked;
    if (isFlying && !canFlyNow){ isFlying=false; }

    if (isFlying){
      let vy=0;
      if (keys['Space']) vy += FLY_V;
      if (keys['ShiftLeft']||keys['ShiftRight']) vy -= FLY_V;
      pos.y += vy * dt;
      if (pos.y < 2){ pos.y = 2; }
      onGround=false; velY=0;
    }else{
      velY += GRAV * dt;
      pos.y += velY * dt;

      const gH = groundHeightAtWorld(pos.x, pos.z);
      const groundY = gH + 2;
      if (pos.y <= groundY){
        pos.y = groundY; velY=0; onGround=true;
      }
      if (pos.y < 2){ pos.y = 2; velY=0; onGround=true; }
    }

    const W = maze[0].length*cellSize, H = maze.length*cellSize;
    const now = performance.now();
    if (now > deathCooldownUntil){
      if (pos.x< -0.5 || pos.z< -0.5 || pos.x>W+0.5 || pos.z>H+0.5){
        killAndRespawn();
      }
    }
    pos.x = Math.max(0.25, Math.min(W-0.25, pos.x));
    pos.z = Math.max(0.25, Math.min(H-0.25, pos.z));

    diamonds = diamonds.filter(d=>{
      if (pos.distanceToSquared(d.position) < 2.56){
        const val = (d.userData.type==='S') ? 20 : 1;
        diamondCount += val; totalDiamonds += val;
        diamondUI.textContent=diamondCount; totalUI.textContent=totalDiamonds; updateHUD();
        scene.remove(d); return false;
      }
      return true;
    });

    const c = playerCell();
    const onExit = (c.x===exitCell.x && c.y===exitCell.y);
    const enough = (diamondCount>=toWin);
    if (onExit){
      if (!onExitCellLast){ exitStartT = performance.now(); }
      if (!enough){
        exitWarn.style.display='block';
        exitRing.style.display='none';
      } else {
        exitWarn.style.display='none';
        exitRing.style.display='block';
        const prog = Math.min(1, (performance.now()-exitStartT)/5000);
        const deg = Math.floor(prog*360);
        exitRing.style.background = `conic-gradient(#44ff77 ${deg}deg, rgba(255,255,255,0.12) ${deg}deg 360deg)`;
        if (prog>=1){ exitRing.style.display='none'; onVictory(); }
      }
    } else {
      exitWarn.style.display='none';
      exitRing.style.display='none';
    }
    onExitCellLast = onExit;

    renderer.render(scene, camera);
    if (debugOn){
      const p = controls.getObject().position;
      const c = playerCell();
      const info = renderer.info;
      debugPanel.textContent =
        `FPS: ${fps} | Quality: ${quality}\n`+
        `DrawCalls: ${info.render.calls}  Tris: ${info.render.triangles}  Lines: ${info.render.lines}  Points: ${info.render.points}\n`+
        `Pos: ${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)}  Cell: ${c.x}, ${c.y}\n`+
        `Mode: ${gameMode}  Flying: ${isFlying}  Ground: ${onGround}  velY: ${velY.toFixed(2)}\n`+
        `Diamonds: carry ${diamondCount} / total ${totalDiamonds}  Levels: ${levelsCleared}\n`+
        `Seeds: maze ${mazeSeed}  diam ${diamondsSeed}  biome ${biomeSeed}  Map: ${mapUnlocked}  Jump: ${jumpUnlockedClassic}`;
    }
    updateMapScene();
  }

  function resetRun(newMazeSeed){
    if (newMazeSeed!=null) reseedMaze(newMazeSeed); else reseedMaze((Math.random()*0x07FF)|0);
    reseedDiam((Math.random()*0x07FF)|0);
    if (gameMode==='biomes') reseedBiome((Math.random()*0x07FF)|0);
    mapUnlocked = false;
    if (gameMode==='classic') jumpUnlockedClassic=false;

    maze = generateMaze(mazeSize, mazeSize);
    buildMazeMesh();
    generateObstaclesIfNeeded();
    buildBiomeMeshes();
    generateDiamondsRef();
    spawnDiamondsFromRef(0n);

    diamondCount = 0; diamondUI.textContent=diamondCount;
    totalUI.textContent = totalDiamonds; levelsUI.textContent = levelsCleared;
    modeUI.textContent = (gameMode==='biomes'?'Biomes':'Classic');

    controls.getObject().position.set((1+0.5)*cellSize, 2, (1+0.5)*cellSize);
    setView(0, 0);

    updateHUD();
    if (mapCanvas.style.display!=='none') buildMapScene();
  }

  function recalcCarryFromMask(mask){
    let sum=0;
    for (let i=0;i<diamondsRef.length;i++){
      if (((mask>>BigInt(i))&1n)===1n){
        sum += (diamondsRef[i].type==='S')?20:1;
      }
    }
    return sum;
  }

  function loadFromCode(str){
    try{
      const d = decodeSave(str);

      gameMode = d.mode ? 'biomes' : 'classic';
      reseedMaze(d.mseed); reseedDiam(d.dseed); reseedBiome(d.bseed);

      maze = generateMaze(mazeSize, mazeSize);
      buildMazeMesh();
      generateObstaclesIfNeeded();
      buildBiomeMeshes();
      generateDiamondsRef();
      spawnDiamondsFromRef(d.mask);

      totalDiamonds  = d.total;
      levelsCleared  = d.levels;
      mapUnlocked    = d.map;
      jumpUnlockedClassic = (gameMode==='classic') ? d.jump : false;

      diamondCount = recalcCarryFromMask(d.mask);

      diamondUI.textContent=diamondCount; totalUI.textContent=totalDiamonds; levelsUI.textContent=levelsCleared;
      modeUI.textContent = (gameMode==='biomes'?'Biomes':'Classic');

      const x = (d.gx + d.fx/15)*cellSize;
      const z = (d.gz + d.fz/15)*cellSize;
      controls.getObject().position.set(x, Math.max(2, d.y), z);

      const yaw   = (d.yaw/31)*Math.PI*2;
      const pitch = (d.pitch/31)*Math.PI*0.98 - Math.PI*0.49;
      setView(yaw, pitch);

      isFlying = d.fly && (gameMode!=='classic' || jumpUnlockedClassic);
      velY=0; onGround = !isFlying && (controls.getObject().position.y<=2.01);

      for (const k in keys) keys[k]=false;
      updateHUD();
      showToast('Сохранение v8 загружено', 'success');

      if (mapCanvas.style.display!=='none') buildMapScene();
    }catch(e){
      console.error(e);
      showToast('Неверный или повреждённый код сохранения (v8)', 'err', 2800);
    }
  }

  function startNew(mode){
    gameMode = mode;
    totalDiamonds=0; diamondCount=0; levelsCleared=0; mapUnlocked=false;
    jumpUnlockedClassic = false;
    resetRun();
    mainMenu.style.display='none';
    setMobileUIVisible(isMobile);
    animate();
    showToast(`Режим: ${mode==='biomes'?'Biomes':'Classic'}`, 'success');
  }

  function goToMainMenu(){
    const code = encodeSave();
    menuInput.value = code;
    try{ controls.unlock && controls.unlock(); }catch{}
    mapCanvas.style.display='none';
    mainMenu.style.display='';
    setMobileUIVisible(false);
    buyRing.style.display='none';
    showToast('Меню. Код сохранения подставлен.', 'warn');
  }

  // === Главное меню ===
  btnClassic.addEventListener('click', ()=>startNew('classic'));
  btnBiomes.addEventListener('click',   ()=>startNew('biomes'));
  btnContinue.addEventListener('click', ()=>{
    const code = menuInput.value.trim();
    if (!code){ showToast('Введите код v8', 'warn'); return; }
    if (!isValidSave(code)){ showToast('Некорректный код v8 — игра не запущена', 'err', 3000); return; }
    mainMenu.style.display='none';
    loadFromCode(code);
    setMobileUIVisible(isMobile);
    animate();
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (mapCanvas.style.display!=='none'){
      const w = mapCanvas.clientWidth, h = mapCanvas.clientHeight;
      mapRenderer.setSize(w, h, false);
      mapCam.aspect = w/h; mapCam.updateProjectionMatrix();
    }
  });

  // старт в меню
})();
</script>
</body>
</html>
